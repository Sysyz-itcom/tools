var Ra = Object.defineProperty; var Ba = (e, t, n) => t in e ? Ra(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var et = (e, t, n) => (Ba(e, typeof t != "symbol" ? t + "" : t, n), n); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); var Xn = !1, Qn = !1, Nt = [], Jn = -1; function ka(e) { Fa(e) } function Fa(e) { Nt.includes(e) || Nt.push(e), Va() } function gs(e) { let t = Nt.indexOf(e); t !== -1 && t > Jn && Nt.splice(t, 1) } function Va() { !Qn && !Xn && (Xn = !0, queueMicrotask(Ha)) } function Ha() { Xn = !1, Qn = !0; for (let e = 0; e < Nt.length; e++)Nt[e](), Jn = e; Nt.length = 0, Jn = -1, Qn = !1 } var te, ee, Ae, ms, Zn = !0; function ja(e) { Zn = !1, e(), Zn = !0 } function Ka(e) { te = e.reactive, Ae = e.release, ee = t => e.effect(t, { scheduler: n => { Zn ? ka(n) : n() } }), ms = e.raw } function Ei(e) { ee = e } function Ua(e) { let t = () => { }; return [r => { let i = ee(r); return e._x_effects || (e._x_effects = new Set, e._x_runEffects = () => { e._x_effects.forEach(s => s()) }), e._x_effects.add(i), t = () => { i !== void 0 && (e._x_effects.delete(i), Ae(i)) }, i }, () => { t() }] } function pe(e, t, n = {}) { e.dispatchEvent(new CustomEvent(t, { detail: n, bubbles: !0, composed: !0, cancelable: !0 })) } function ft(e, t) { if (typeof ShadowRoot == "function" && e instanceof ShadowRoot) { Array.from(e.children).forEach(i => ft(i, t)); return } let n = !1; if (t(e, () => n = !0), n) return; let r = e.firstElementChild; for (; r;)ft(r, t), r = r.nextElementSibling } function it(e, ...t) { } var bi = !1; function Wa() { bi && it("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."), bi = !0, document.body || it("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), pe(document, "alpine:init"), pe(document, "alpine:initializing"), xr(), qa(t => st(t, ft)), Sr(t => Tr(t)), Cs((t, n) => { Lr(t, n).forEach(r => r()) }); let e = t => !fn(t.parentElement, !0); Array.from(document.querySelectorAll(bs().join(","))).filter(e).forEach(t => { st(t) }), pe(document, "alpine:initialized") } var wr = [], vs = []; function Es() { return wr.map(e => e()) } function bs() { return wr.concat(vs).map(e => e()) } function ys(e) { wr.push(e) } function As(e) { vs.push(e) } function fn(e, t = !1) { return dn(e, n => { if ((t ? bs() : Es()).some(i => n.matches(i))) return !0 }) } function dn(e, t) { if (e) { if (t(e)) return e; if (e._x_teleportBack && (e = e._x_teleportBack), !!e.parentElement) return dn(e.parentElement, t) } } function Ya(e) { return Es().some(t => e.matches(t)) } var ws = []; function za(e) { ws.push(e) } function st(e, t = ft, n = () => { }) { lc(() => { t(e, (r, i) => { n(r, i), ws.forEach(s => s(r, i)), Lr(r, r.attributes).forEach(s => s()), r._x_ignore && i() }) }) } function Tr(e) { ft(e, t => { Ns(t), Ga(t) }) } var Ts = [], Ss = [], Os = []; function qa(e) { Os.push(e) } function Sr(e, t) { typeof t == "function" ? (e._x_cleanups || (e._x_cleanups = []), e._x_cleanups.push(t)) : (t = e, Ss.push(t)) } function Cs(e) { Ts.push(e) } function xs(e, t, n) { e._x_attributeCleanups || (e._x_attributeCleanups = {}), e._x_attributeCleanups[t] || (e._x_attributeCleanups[t] = []), e._x_attributeCleanups[t].push(n) } function Ns(e, t) { e._x_attributeCleanups && Object.entries(e._x_attributeCleanups).forEach(([n, r]) => { (t === void 0 || t.includes(n)) && (r.forEach(i => i()), delete e._x_attributeCleanups[n]) }) } function Ga(e) { if (e._x_cleanups) for (; e._x_cleanups.length;)e._x_cleanups.pop()() } var Or = new MutationObserver(Dr), Cr = !1; function xr() { Or.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), Cr = !0 } function Ds() { Xa(), Or.disconnect(), Cr = !1 } var _e = [], Nn = !1; function Xa() { _e = _e.concat(Or.takeRecords()), _e.length && !Nn && (Nn = !0, queueMicrotask(() => { Qa(), Nn = !1 })) } function Qa() { Dr(_e), _e.length = 0 } function $(e) { if (!Cr) return e(); Ds(); let t = e(); return xr(), t } var Nr = !1, rn = []; function Ja() { Nr = !0 } function Za() { Nr = !1, Dr(rn), rn = [] } function Dr(e) { if (Nr) { rn = rn.concat(e); return } let t = [], n = [], r = new Map, i = new Map; for (let s = 0; s < e.length; s++)if (!e[s].target._x_ignoreMutationObserver && (e[s].type === "childList" && (e[s].addedNodes.forEach(o => o.nodeType === 1 && t.push(o)), e[s].removedNodes.forEach(o => o.nodeType === 1 && n.push(o))), e[s].type === "attributes")) { let o = e[s].target, a = e[s].attributeName, u = e[s].oldValue, g = () => { r.has(o) || r.set(o, []), r.get(o).push({ name: a, value: o.getAttribute(a) }) }, _ = () => { i.has(o) || i.set(o, []), i.get(o).push(a) }; o.hasAttribute(a) && u === null ? g() : o.hasAttribute(a) ? (_(), g()) : _() } i.forEach((s, o) => { Ns(o, s) }), r.forEach((s, o) => { Ts.forEach(a => a(o, s)) }); for (let s of n) t.includes(s) || (Ss.forEach(o => o(s)), Tr(s)); t.forEach(s => { s._x_ignoreSelf = !0, s._x_ignore = !0 }); for (let s of t) n.includes(s) || s.isConnected && (delete s._x_ignoreSelf, delete s._x_ignore, Os.forEach(o => o(s)), s._x_ignore = !0, s._x_ignoreSelf = !0); t.forEach(s => { delete s._x_ignoreSelf, delete s._x_ignore }), t = null, n = null, r = null, i = null } function $s(e) { return Te(Wt(e)) } function we(e, t, n) { return e._x_dataStack = [t, ...Wt(n || e)], () => { e._x_dataStack = e._x_dataStack.filter(r => r !== t) } } function Wt(e) { return e._x_dataStack ? e._x_dataStack : typeof ShadowRoot == "function" && e instanceof ShadowRoot ? Wt(e.host) : e.parentNode ? Wt(e.parentNode) : [] } function Te(e) { return new Proxy({ objects: e }, tc) } var tc = { ownKeys({ objects: e }) { return Array.from(new Set(e.flatMap(t => Object.keys(t)))) }, has({ objects: e }, t) { return t == Symbol.unscopables ? !1 : e.some(n => Object.prototype.hasOwnProperty.call(n, t)) }, get({ objects: e }, t, n) { return t == "toJSON" ? ec : Reflect.get(e.find(r => Object.prototype.hasOwnProperty.call(r, t)) || {}, t, n) }, set({ objects: e }, t, n, r) { const i = e.find(o => Object.prototype.hasOwnProperty.call(o, t)) || e[e.length - 1], s = Object.getOwnPropertyDescriptor(i, t); return s != null && s.set && (s != null && s.get) ? Reflect.set(i, t, n, r) : Reflect.set(i, t, n) } }; function ec() { return Reflect.ownKeys(this).reduce((t, n) => (t[n] = Reflect.get(this, n), t), {}) } function Ls(e) { let t = r => typeof r == "object" && !Array.isArray(r) && r !== null, n = (r, i = "") => { Object.entries(Object.getOwnPropertyDescriptors(r)).forEach(([s, { value: o, enumerable: a }]) => { if (a === !1 || o === void 0) return; let u = i === "" ? s : `${i}.${s}`; typeof o == "object" && o !== null && o._x_interceptor ? r[s] = o.initialize(e, u, s) : t(o) && o !== r && !(o instanceof Element) && n(o, u) }) }; return n(e) } function Is(e, t = () => { }) { let n = { initialValue: void 0, _x_interceptor: !0, initialize(r, i, s) { return e(this.initialValue, () => nc(r, i), o => tr(r, i, o), i, s) } }; return t(n), r => { if (typeof r == "object" && r !== null && r._x_interceptor) { let i = n.initialize.bind(n); n.initialize = (s, o, a) => { let u = r.initialize(s, o, a); return n.initialValue = u, i(s, o, a) } } else n.initialValue = r; return n } } function nc(e, t) { return t.split(".").reduce((n, r) => n[r], e) } function tr(e, t, n) { if (typeof t == "string" && (t = t.split(".")), t.length === 1) e[t[0]] = n; else { if (t.length === 0) throw error; return e[t[0]] || (e[t[0]] = {}), tr(e[t[0]], t.slice(1), n) } } var Ms = {}; function G(e, t) { Ms[e] = t } function er(e, t) { return Object.entries(Ms).forEach(([n, r]) => { let i = null; function s() { if (i) return i; { let [o, a] = Vs(t); return i = { interceptor: Is, ...o }, Sr(t, a), i } } Object.defineProperty(e, `$${n}`, { get() { return r(t, s()) }, enumerable: !1 }) }), e } function rc(e, t, n, ...r) { try { return n(...r) } catch (i) { be(i, e, t) } } function be(e, t, n = void 0) { Object.assign(e, { el: t, expression: n }), setTimeout(() => { throw e }, 0) } var Qe = !0; function Ps(e) { let t = Qe; Qe = !1; let n = e(); return Qe = t, n } function Dt(e, t, n = {}) { let r; return M(e, t)(i => r = i, n), r } function M(...e) { return Rs(...e) } var Rs = Bs; function ic(e) { Rs = e } function Bs(e, t) { let n = {}; er(n, e); let r = [n, ...Wt(e)], i = typeof t == "function" ? sc(r, t) : ac(r, t, e); return rc.bind(null, e, t, i) } function sc(e, t) { return (n = () => { }, { scope: r = {}, params: i = [] } = {}) => { let s = t.apply(Te([r, ...e]), i); sn(n, s) } } var Dn = {}; function oc(e, t) { if (Dn[e]) return Dn[e]; let n = Object.getPrototypeOf(async function () { }).constructor, r = /^[\n\s]*if.*\(.*\)/.test(e.trim()) || /^(let|const)\s/.test(e.trim()) ? `(async()=>{ ${e} })()` : e, s = (() => { try { let o = new n(["__self", "scope"], `with (scope) { __self.result = ${r} }; __self.finished = true; return __self.result;`); return Object.defineProperty(o, "name", { value: `[Alpine] ${e}` }), o } catch (o) { return be(o, t, e), Promise.resolve() } })(); return Dn[e] = s, s } function ac(e, t, n) { let r = oc(t, n); return (i = () => { }, { scope: s = {}, params: o = [] } = {}) => { r.result = void 0, r.finished = !1; let a = Te([s, ...e]); if (typeof r == "function") { let u = r(r, a).catch(g => be(g, n, t)); r.finished ? (sn(i, r.result, a, o, n), r.result = void 0) : u.then(g => { sn(i, g, a, o, n) }).catch(g => be(g, n, t)).finally(() => r.result = void 0) } } } function sn(e, t, n, r, i) { if (Qe && typeof t == "function") { let s = t.apply(n, r); s instanceof Promise ? s.then(o => sn(e, o, n, r)).catch(o => be(o, i, t)) : e(s) } else typeof t == "object" && t instanceof Promise ? t.then(s => e(s)) : e(t) } var $r = "x-"; function ne(e = "") { return $r + e } function cc(e) { $r = e } var nr = {}; function D(e, t) { return nr[e] = t, { before(n) { if (!nr[n]) return; const r = Ot.indexOf(n); Ot.splice(r >= 0 ? r : Ot.indexOf("DEFAULT"), 0, e) } } } function Lr(e, t, n) { if (t = Array.from(t), e._x_virtualDirectives) { let s = Object.entries(e._x_virtualDirectives).map(([a, u]) => ({ name: a, value: u })), o = ks(s); s = s.map(a => o.find(u => u.name === a.name) ? { name: `x-bind:${a.name}`, value: `"${a.value}"` } : a), t = t.concat(s) } let r = {}; return t.map(Ks((s, o) => r[s] = o)).filter(Ws).map(fc(r, n)).sort(dc).map(s => uc(e, s)) } function ks(e) { return Array.from(e).map(Ks()).filter(t => !Ws(t)) } var rr = !1, he = new Map, Fs = Symbol(); function lc(e) { rr = !0; let t = Symbol(); Fs = t, he.set(t, []); let n = () => { for (; he.get(t).length;)he.get(t).shift()(); he.delete(t) }, r = () => { rr = !1, n() }; e(n), r() } function Vs(e) { let t = [], n = a => t.push(a), [r, i] = Ua(e); return t.push(i), [{ Alpine: Oe, effect: r, cleanup: n, evaluateLater: M.bind(M, e), evaluate: Dt.bind(Dt, e) }, () => t.forEach(a => a())] } function uc(e, t) { let n = () => { }, r = nr[t.type] || n, [i, s] = Vs(e); xs(e, t.original, s); let o = () => { e._x_ignore || e._x_ignoreSelf || (r.inline && r.inline(e, t, i), r = r.bind(r, e, t, i), rr ? he.get(Fs).push(r) : r()) }; return o.runCleanups = s, o } var Hs = (e, t) => ({ name: n, value: r }) => (n.startsWith(e) && (n = n.replace(e, t)), { name: n, value: r }), js = e => e; function Ks(e = () => { }) { return ({ name: t, value: n }) => { let { name: r, value: i } = Us.reduce((s, o) => o(s), { name: t, value: n }); return r !== t && e(r, t), { name: r, value: i } } } var Us = []; function Ir(e) { Us.push(e) } function Ws({ name: e }) { return Ys().test(e) } var Ys = () => new RegExp(`^${$r}([^:^.]+)\\b`); function fc(e, t) { return ({ name: n, value: r }) => { let i = n.match(Ys()), s = n.match(/:([a-zA-Z0-9\-_:]+)/), o = n.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], a = t || e[n] || n; return { type: i ? i[1] : null, value: s ? s[1] : null, modifiers: o.map(u => u.replace(".", "")), expression: r, original: a } } } var ir = "DEFAULT", Ot = ["ignore", "ref", "data", "id", "anchor", "bind", "init", "for", "model", "modelable", "transition", "show", "if", ir, "teleport"]; function dc(e, t) { let n = Ot.indexOf(e.type) === -1 ? ir : e.type, r = Ot.indexOf(t.type) === -1 ? ir : t.type; return Ot.indexOf(n) - Ot.indexOf(r) } var sr = [], Mr = !1; function Pr(e = () => { }) { return queueMicrotask(() => { Mr || setTimeout(() => { or() }) }), new Promise(t => { sr.push(() => { e(), t() }) }) } function or() { for (Mr = !1; sr.length;)sr.shift()() } function hc() { Mr = !0 } function Rr(e, t) { return Array.isArray(t) ? yi(e, t.join(" ")) : typeof t == "object" && t !== null ? pc(e, t) : typeof t == "function" ? Rr(e, t()) : yi(e, t) } function yi(e, t) { let n = i => i.split(" ").filter(s => !e.classList.contains(s)).filter(Boolean), r = i => (e.classList.add(...i), () => { e.classList.remove(...i) }); return t = t === !0 ? t = "" : t || "", r(n(t)) } function pc(e, t) { let n = a => a.split(" ").filter(Boolean), r = Object.entries(t).flatMap(([a, u]) => u ? n(a) : !1).filter(Boolean), i = Object.entries(t).flatMap(([a, u]) => u ? !1 : n(a)).filter(Boolean), s = [], o = []; return i.forEach(a => { e.classList.contains(a) && (e.classList.remove(a), o.push(a)) }), r.forEach(a => { e.classList.contains(a) || (e.classList.add(a), s.push(a)) }), () => { o.forEach(a => e.classList.add(a)), s.forEach(a => e.classList.remove(a)) } } function hn(e, t) { return typeof t == "object" && t !== null ? _c(e, t) : gc(e, t) } function _c(e, t) { let n = {}; return Object.entries(t).forEach(([r, i]) => { n[r] = e.style[r], r.startsWith("--") || (r = mc(r)), e.style.setProperty(r, i) }), setTimeout(() => { e.style.length === 0 && e.removeAttribute("style") }), () => { hn(e, n) } } function gc(e, t) { let n = e.getAttribute("style", t); return e.setAttribute("style", t), () => { e.setAttribute("style", n || "") } } function mc(e) { return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function ar(e, t = () => { }) { let n = !1; return function () { n ? t.apply(this, arguments) : (n = !0, e.apply(this, arguments)) } } D("transition", (e, { value: t, modifiers: n, expression: r }, { evaluate: i }) => { typeof r == "function" && (r = i(r)), r !== !1 && (!r || typeof r == "boolean" ? Ec(e, n, t) : vc(e, r, t)) }); function vc(e, t, n) { zs(e, Rr, ""), { enter: i => { e._x_transition.enter.during = i }, "enter-start": i => { e._x_transition.enter.start = i }, "enter-end": i => { e._x_transition.enter.end = i }, leave: i => { e._x_transition.leave.during = i }, "leave-start": i => { e._x_transition.leave.start = i }, "leave-end": i => { e._x_transition.leave.end = i } }[n](t) } function Ec(e, t, n) { zs(e, hn); let r = !t.includes("in") && !t.includes("out") && !n, i = r || t.includes("in") || ["enter"].includes(n), s = r || t.includes("out") || ["leave"].includes(n); t.includes("in") && !r && (t = t.filter((p, h) => h < t.indexOf("out"))), t.includes("out") && !r && (t = t.filter((p, h) => h > t.indexOf("out"))); let o = !t.includes("opacity") && !t.includes("scale"), a = o || t.includes("opacity"), u = o || t.includes("scale"), g = a ? 0 : 1, _ = u ? le(t, "scale", 95) / 100 : 1, E = le(t, "delay", 0) / 1e3, b = le(t, "origin", "center"), y = "opacity, transform", S = le(t, "duration", 150) / 1e3, w = le(t, "duration", 75) / 1e3, m = "cubic-bezier(0.4, 0.0, 0.2, 1)"; i && (e._x_transition.enter.during = { transformOrigin: b, transitionDelay: `${E}s`, transitionProperty: y, transitionDuration: `${S}s`, transitionTimingFunction: m }, e._x_transition.enter.start = { opacity: g, transform: `scale(${_})` }, e._x_transition.enter.end = { opacity: 1, transform: "scale(1)" }), s && (e._x_transition.leave.during = { transformOrigin: b, transitionDelay: `${E}s`, transitionProperty: y, transitionDuration: `${w}s`, transitionTimingFunction: m }, e._x_transition.leave.start = { opacity: 1, transform: "scale(1)" }, e._x_transition.leave.end = { opacity: g, transform: `scale(${_})` }) } function zs(e, t, n = {}) { e._x_transition || (e._x_transition = { enter: { during: n, start: n, end: n }, leave: { during: n, start: n, end: n }, in(r = () => { }, i = () => { }) { cr(e, t, { during: this.enter.during, start: this.enter.start, end: this.enter.end }, r, i) }, out(r = () => { }, i = () => { }) { cr(e, t, { during: this.leave.during, start: this.leave.start, end: this.leave.end }, r, i) } }) } window.Element.prototype._x_toggleAndCascadeWithTransitions = function (e, t, n, r) { const i = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout; let s = () => i(n); if (t) { e._x_transition && (e._x_transition.enter || e._x_transition.leave) ? e._x_transition.enter && (Object.entries(e._x_transition.enter.during).length || Object.entries(e._x_transition.enter.start).length || Object.entries(e._x_transition.enter.end).length) ? e._x_transition.in(n) : s() : e._x_transition ? e._x_transition.in(n) : s(); return } e._x_hidePromise = e._x_transition ? new Promise((o, a) => { e._x_transition.out(() => { }, () => o(r)), e._x_transitioning && e._x_transitioning.beforeCancel(() => a({ isFromCancelledTransition: !0 })) }) : Promise.resolve(r), queueMicrotask(() => { let o = qs(e); o ? (o._x_hideChildren || (o._x_hideChildren = []), o._x_hideChildren.push(e)) : i(() => { let a = u => { let g = Promise.all([u._x_hidePromise, ...(u._x_hideChildren || []).map(a)]).then(([_]) => _()); return delete u._x_hidePromise, delete u._x_hideChildren, g }; a(e).catch(u => { if (!u.isFromCancelledTransition) throw u }) }) }) }; function qs(e) { let t = e.parentNode; if (t) return t._x_hidePromise ? t : qs(t) } function cr(e, t, { during: n, start: r, end: i } = {}, s = () => { }, o = () => { }) { if (e._x_transitioning && e._x_transitioning.cancel(), Object.keys(n).length === 0 && Object.keys(r).length === 0 && Object.keys(i).length === 0) { s(), o(); return } let a, u, g; bc(e, { start() { a = t(e, r) }, during() { u = t(e, n) }, before: s, end() { a(), g = t(e, i) }, after: o, cleanup() { u(), g() } }) } function bc(e, t) { let n, r, i, s = ar(() => { $(() => { n = !0, r || t.before(), i || (t.end(), or()), t.after(), e.isConnected && t.cleanup(), delete e._x_transitioning }) }); e._x_transitioning = { beforeCancels: [], beforeCancel(o) { this.beforeCancels.push(o) }, cancel: ar(function () { for (; this.beforeCancels.length;)this.beforeCancels.shift()(); s() }), finish: s }, $(() => { t.start(), t.during() }), hc(), requestAnimationFrame(() => { if (n) return; let o = Number(getComputedStyle(e).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3, a = Number(getComputedStyle(e).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3; o === 0 && (o = Number(getComputedStyle(e).animationDuration.replace("s", "")) * 1e3), $(() => { t.before() }), r = !0, requestAnimationFrame(() => { n || ($(() => { t.end() }), or(), setTimeout(e._x_transitioning.finish, o + a), i = !0) }) }) } function le(e, t, n) { if (e.indexOf(t) === -1) return n; const r = e[e.indexOf(t) + 1]; if (!r || t === "scale" && isNaN(r)) return n; if (t === "duration" || t === "delay") { let i = r.match(/([0-9]+)ms/); if (i) return i[1] } return t === "origin" && ["top", "right", "left", "center", "bottom"].includes(e[e.indexOf(t) + 2]) ? [r, e[e.indexOf(t) + 2]].join(" ") : r } var dt = !1; function Se(e, t = () => { }) { return (...n) => dt ? t(...n) : e(...n) } function yc(e) { return (...t) => dt && e(...t) } var Gs = []; function Xs(e) { Gs.push(e) } function Ac(e, t) { Gs.forEach(n => n(e, t)), dt = !0, Qs(() => { st(t, (n, r) => { r(n, () => { }) }) }), dt = !1 } var lr = !1; function wc(e, t) { t._x_dataStack || (t._x_dataStack = e._x_dataStack), dt = !0, lr = !0, Qs(() => { Tc(t) }), dt = !1, lr = !1 } function Tc(e) { let t = !1; st(e, (r, i) => { ft(r, (s, o) => { if (t && Ya(s)) return o(); t = !0, i(s, o) }) }) } function Qs(e) { let t = ee; Ei((n, r) => { let i = t(n); return Ae(i), () => { } }), e(), Ei(t) } function Js(e, t, n, r = []) { switch (e._x_bindings || (e._x_bindings = te({})), e._x_bindings[t] = n, t = r.includes("camel") ? Lc(t) : t, t) { case "value": Sc(e, n); break; case "style": Cc(e, n); break; case "class": Oc(e, n); break; case "selected": case "checked": xc(e, t, n); break; default: Zs(e, t, n); break } } function Sc(e, t) { if (e.type === "radio") e.attributes.value === void 0 && (e.value = t), window.fromModel && (typeof t == "boolean" ? e.checked = Je(e.value) === t : e.checked = Ai(e.value, t)); else if (e.type === "checkbox") Number.isInteger(t) ? e.value = t : !Array.isArray(t) && typeof t != "boolean" && ![null, void 0].includes(t) ? e.value = String(t) : Array.isArray(t) ? e.checked = t.some(n => Ai(n, e.value)) : e.checked = !!t; else if (e.tagName === "SELECT") $c(e, t); else { if (e.value === t) return; e.value = t === void 0 ? "" : t } } function Oc(e, t) { e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedClasses = Rr(e, t) } function Cc(e, t) { e._x_undoAddedStyles && e._x_undoAddedStyles(), e._x_undoAddedStyles = hn(e, t) } function xc(e, t, n) { Zs(e, t, n), Dc(e, t, n) } function Zs(e, t, n) { [null, void 0, !1].includes(n) && Ic(t) ? e.removeAttribute(t) : (to(t) && (n = t), Nc(e, t, n)) } function Nc(e, t, n) { e.getAttribute(t) != n && e.setAttribute(t, n) } function Dc(e, t, n) { e[t] !== n && (e[t] = n) } function $c(e, t) { const n = [].concat(t).map(r => r + ""); Array.from(e.options).forEach(r => { r.selected = n.includes(r.value) }) } function Lc(e) { return e.toLowerCase().replace(/-(\w)/g, (t, n) => n.toUpperCase()) } function Ai(e, t) { return e == t } function Je(e) { return [1, "1", "true", "on", "yes", !0].includes(e) ? !0 : [0, "0", "false", "off", "no", !1].includes(e) ? !1 : e ? !!e : null } function to(e) { return ["disabled", "checked", "required", "readonly", "hidden", "open", "selected", "autofocus", "itemscope", "multiple", "novalidate", "allowfullscreen", "allowpaymentrequest", "formnovalidate", "autoplay", "controls", "loop", "muted", "playsinline", "default", "ismap", "reversed", "async", "defer", "nomodule"].includes(e) } function Ic(e) { return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(e) } function Mc(e, t, n) { return e._x_bindings && e._x_bindings[t] !== void 0 ? e._x_bindings[t] : eo(e, t, n) } function Pc(e, t, n, r = !0) { if (e._x_bindings && e._x_bindings[t] !== void 0) return e._x_bindings[t]; if (e._x_inlineBindings && e._x_inlineBindings[t] !== void 0) { let i = e._x_inlineBindings[t]; return i.extract = r, Ps(() => Dt(e, i.expression)) } return eo(e, t, n) } function eo(e, t, n) { let r = e.getAttribute(t); return r === null ? typeof n == "function" ? n() : n : r === "" ? !0 : to(t) ? !![t, "true"].includes(r) : r } function no(e, t) { var n; return function () { var r = this, i = arguments, s = function () { n = null, e.apply(r, i) }; clearTimeout(n), n = setTimeout(s, t) } } function ro(e, t) { let n; return function () { let r = this, i = arguments; n || (e.apply(r, i), n = !0, setTimeout(() => n = !1, t)) } } function io({ get: e, set: t }, { get: n, set: r }) { let i = !0, s, o = ee(() => { const a = e(), u = n(); if (i) r($n(a)), i = !1, s = JSON.stringify(a); else { const g = JSON.stringify(a); g !== s ? (r($n(a)), s = g) : (t($n(u)), s = JSON.stringify(u)) } JSON.stringify(n()), JSON.stringify(e()) }); return () => { Ae(o) } } function $n(e) { return typeof e == "object" ? JSON.parse(JSON.stringify(e)) : e } function Rc(e) { (Array.isArray(e) ? e : [e]).forEach(n => n(Oe)) } var St = {}, wi = !1; function Bc(e, t) { if (wi || (St = te(St), wi = !0), t === void 0) return St[e]; St[e] = t, typeof t == "object" && t !== null && t.hasOwnProperty("init") && typeof t.init == "function" && St[e].init(), Ls(St[e]) } function kc() { return St } var so = {}; function Fc(e, t) { let n = typeof t != "function" ? () => t : t; return e instanceof Element ? oo(e, n()) : (so[e] = n, () => { }) } function Vc(e) { return Object.entries(so).forEach(([t, n]) => { Object.defineProperty(e, t, { get() { return (...r) => n(...r) } }) }), e } function oo(e, t, n) { let r = []; for (; r.length;)r.pop()(); let i = Object.entries(t).map(([o, a]) => ({ name: o, value: a })), s = ks(i); return i = i.map(o => s.find(a => a.name === o.name) ? { name: `x-bind:${o.name}`, value: `"${o.value}"` } : o), Lr(e, i, n).map(o => { r.push(o.runCleanups), o() }), () => { for (; r.length;)r.pop()() } } var ao = {}; function Hc(e, t) { ao[e] = t } function jc(e, t) { return Object.entries(ao).forEach(([n, r]) => { Object.defineProperty(e, n, { get() { return (...i) => r.bind(t)(...i) }, enumerable: !1 }) }), e } var Kc = { get reactive() { return te }, get release() { return Ae }, get effect() { return ee }, get raw() { return ms }, version: "3.13.3", flushAndStopDeferringMutations: Za, dontAutoEvaluateFunctions: Ps, disableEffectScheduling: ja, startObservingMutations: xr, stopObservingMutations: Ds, setReactivityEngine: Ka, onAttributeRemoved: xs, onAttributesAdded: Cs, closestDataStack: Wt, skipDuringClone: Se, onlyDuringClone: yc, addRootSelector: ys, addInitSelector: As, interceptClone: Xs, addScopeToNode: we, deferMutations: Ja, mapAttributes: Ir, evaluateLater: M, interceptInit: za, setEvaluator: ic, mergeProxies: Te, extractProp: Pc, findClosest: dn, onElRemoved: Sr, closestRoot: fn, destroyTree: Tr, interceptor: Is, transition: cr, setStyles: hn, mutateDom: $, directive: D, entangle: io, throttle: ro, debounce: no, evaluate: Dt, initTree: st, nextTick: Pr, prefixed: ne, prefix: cc, plugin: Rc, magic: G, store: Bc, start: Wa, clone: wc, cloneNode: Ac, bound: Mc, $data: $s, walk: ft, data: Hc, bind: Fc }, Oe = Kc; function Uc(e, t) { const n = Object.create(null), r = e.split(","); for (let i = 0; i < r.length; i++)n[r[i]] = !0; return t ? i => !!n[i.toLowerCase()] : i => !!n[i] } var Wc = Object.freeze({}), Yc = Object.prototype.hasOwnProperty, pn = (e, t) => Yc.call(e, t), $t = Array.isArray, ge = e => co(e) === "[object Map]", zc = e => typeof e == "string", Br = e => typeof e == "symbol", _n = e => e !== null && typeof e == "object", qc = Object.prototype.toString, co = e => qc.call(e), lo = e => co(e).slice(8, -1), kr = e => zc(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Gc = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, h_ = Gc(e => e.charAt(0).toUpperCase() + e.slice(1)), uo = (e, t) => e !== t && (e === e || t === t), ur = new WeakMap, ue = [], Q, Lt = Symbol("iterate"), fr = Symbol("Map key iterate"); function Xc(e) { return e && e._isEffect === !0 } function Qc(e, t = Wc) { Xc(e) && (e = e.raw); const n = tl(e, t); return t.lazy || n(), n } function Jc(e) { e.active && (fo(e), e.options.onStop && e.options.onStop(), e.active = !1) } var Zc = 0; function tl(e, t) { const n = function () { if (!n.active) return e(); if (!ue.includes(n)) { fo(n); try { return nl(), ue.push(n), Q = n, e() } finally { ue.pop(), ho(), Q = ue[ue.length - 1] } } }; return n.id = Zc++, n.allowRecurse = !!t.allowRecurse, n._isEffect = !0, n.active = !0, n.raw = e, n.deps = [], n.options = t, n } function fo(e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } } var Yt = !0, Fr = []; function el() { Fr.push(Yt), Yt = !1 } function nl() { Fr.push(Yt), Yt = !0 } function ho() { const e = Fr.pop(); Yt = e === void 0 ? !0 : e } function q(e, t, n) { if (!Yt || Q === void 0) return; let r = ur.get(e); r || ur.set(e, r = new Map); let i = r.get(n); i || r.set(n, i = new Set), i.has(Q) || (i.add(Q), Q.deps.push(i), Q.options.onTrack && Q.options.onTrack({ effect: Q, target: e, type: t, key: n })) } function ht(e, t, n, r, i, s) { const o = ur.get(e); if (!o) return; const a = new Set, u = _ => { _ && _.forEach(E => { (E !== Q || E.allowRecurse) && a.add(E) }) }; if (t === "clear") o.forEach(u); else if (n === "length" && $t(e)) o.forEach((_, E) => { (E === "length" || E >= r) && u(_) }); else switch (n !== void 0 && u(o.get(n)), t) { case "add": $t(e) ? kr(n) && u(o.get("length")) : (u(o.get(Lt)), ge(e) && u(o.get(fr))); break; case "delete": $t(e) || (u(o.get(Lt)), ge(e) && u(o.get(fr))); break; case "set": ge(e) && u(o.get(Lt)); break }const g = _ => { _.options.onTrigger && _.options.onTrigger({ effect: _, target: e, key: n, type: t, newValue: r, oldValue: i, oldTarget: s }), _.options.scheduler ? _.options.scheduler(_) : _() }; a.forEach(g) } var rl = Uc("__proto__,__v_isRef,__isVue"), po = new Set(Object.getOwnPropertyNames(Symbol).map(e => Symbol[e]).filter(Br)), il = _o(), sl = _o(!0), Ti = ol(); function ol() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(t => { e[t] = function (...n) { const r = N(this); for (let s = 0, o = this.length; s < o; s++)q(r, "get", s + ""); const i = r[t](...n); return i === -1 || i === !1 ? r[t](...n.map(N)) : i } }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => { e[t] = function (...n) { el(); const r = N(this)[t].apply(this, n); return ho(), r } }), e } function _o(e = !1, t = !1) { return function (r, i, s) { if (i === "__v_isReactive") return !e; if (i === "__v_isReadonly") return e; if (i === "__v_raw" && s === (e ? t ? Al : Eo : t ? yl : vo).get(r)) return r; const o = $t(r); if (!e && o && pn(Ti, i)) return Reflect.get(Ti, i, s); const a = Reflect.get(r, i, s); return (Br(i) ? po.has(i) : rl(i)) || (e || q(r, "get", i), t) ? a : dr(a) ? !o || !kr(i) ? a.value : a : _n(a) ? e ? bo(a) : Kr(a) : a } } var al = cl(); function cl(e = !1) { return function (n, r, i, s) { let o = n[r]; if (!e && (i = N(i), o = N(o), !$t(n) && dr(o) && !dr(i))) return o.value = i, !0; const a = $t(n) && kr(r) ? Number(r) < n.length : pn(n, r), u = Reflect.set(n, r, i, s); return n === N(s) && (a ? uo(i, o) && ht(n, "set", r, i, o) : ht(n, "add", r, i)), u } } function ll(e, t) { const n = pn(e, t), r = e[t], i = Reflect.deleteProperty(e, t); return i && n && ht(e, "delete", t, void 0, r), i } function ul(e, t) { const n = Reflect.has(e, t); return (!Br(t) || !po.has(t)) && q(e, "has", t), n } function fl(e) { return q(e, "iterate", $t(e) ? "length" : Lt), Reflect.ownKeys(e) } var dl = { get: il, set: al, deleteProperty: ll, has: ul, ownKeys: fl }, hl = { get: sl, set(e, t) { return !0 }, deleteProperty(e, t) { return !0 } }, Vr = e => _n(e) ? Kr(e) : e, Hr = e => _n(e) ? bo(e) : e, jr = e => e, gn = e => Reflect.getPrototypeOf(e); function ke(e, t, n = !1, r = !1) { e = e.__v_raw; const i = N(e), s = N(t); t !== s && !n && q(i, "get", t), !n && q(i, "get", s); const { has: o } = gn(i), a = r ? jr : n ? Hr : Vr; if (o.call(i, t)) return a(e.get(t)); if (o.call(i, s)) return a(e.get(s)); e !== i && e.get(t) } function Fe(e, t = !1) { const n = this.__v_raw, r = N(n), i = N(e); return e !== i && !t && q(r, "has", e), !t && q(r, "has", i), e === i ? n.has(e) : n.has(e) || n.has(i) } function Ve(e, t = !1) { return e = e.__v_raw, !t && q(N(e), "iterate", Lt), Reflect.get(e, "size", e) } function Si(e) { e = N(e); const t = N(this); return gn(t).has.call(t, e) || (t.add(e), ht(t, "add", e, e)), this } function Oi(e, t) { t = N(t); const n = N(this), { has: r, get: i } = gn(n); let s = r.call(n, e); s ? mo(n, r, e) : (e = N(e), s = r.call(n, e)); const o = i.call(n, e); return n.set(e, t), s ? uo(t, o) && ht(n, "set", e, t, o) : ht(n, "add", e, t), this } function Ci(e) { const t = N(this), { has: n, get: r } = gn(t); let i = n.call(t, e); i ? mo(t, n, e) : (e = N(e), i = n.call(t, e)); const s = r ? r.call(t, e) : void 0, o = t.delete(e); return i && ht(t, "delete", e, void 0, s), o } function xi() { const e = N(this), t = e.size !== 0, n = ge(e) ? new Map(e) : new Set(e), r = e.clear(); return t && ht(e, "clear", void 0, void 0, n), r } function He(e, t) { return function (r, i) { const s = this, o = s.__v_raw, a = N(o), u = t ? jr : e ? Hr : Vr; return !e && q(a, "iterate", Lt), o.forEach((g, _) => r.call(i, u(g), u(_), s)) } } function je(e, t, n) { return function (...r) { const i = this.__v_raw, s = N(i), o = ge(s), a = e === "entries" || e === Symbol.iterator && o, u = e === "keys" && o, g = i[e](...r), _ = n ? jr : t ? Hr : Vr; return !t && q(s, "iterate", u ? fr : Lt), { next() { const { value: E, done: b } = g.next(); return b ? { value: E, done: b } : { value: a ? [_(E[0]), _(E[1])] : _(E), done: b } }, [Symbol.iterator]() { return this } } } } function lt(e) { return function (...t) { { const n = t[0] ? `on key "${t[0]}" ` : "" } return e === "delete" ? !1 : this } } function pl() { const e = { get(s) { return ke(this, s) }, get size() { return Ve(this) }, has: Fe, add: Si, set: Oi, delete: Ci, clear: xi, forEach: He(!1, !1) }, t = { get(s) { return ke(this, s, !1, !0) }, get size() { return Ve(this) }, has: Fe, add: Si, set: Oi, delete: Ci, clear: xi, forEach: He(!1, !0) }, n = { get(s) { return ke(this, s, !0) }, get size() { return Ve(this, !0) }, has(s) { return Fe.call(this, s, !0) }, add: lt("add"), set: lt("set"), delete: lt("delete"), clear: lt("clear"), forEach: He(!0, !1) }, r = { get(s) { return ke(this, s, !0, !0) }, get size() { return Ve(this, !0) }, has(s) { return Fe.call(this, s, !0) }, add: lt("add"), set: lt("set"), delete: lt("delete"), clear: lt("clear"), forEach: He(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(s => { e[s] = je(s, !1, !1), n[s] = je(s, !0, !1), t[s] = je(s, !1, !0), r[s] = je(s, !0, !0) }), [e, n, t, r] } var [_l, gl, ml, vl] = pl(); function go(e, t) { const n = t ? e ? vl : ml : e ? gl : _l; return (r, i, s) => i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? r : Reflect.get(pn(n, i) && i in r ? n : r, i, s) } var El = { get: go(!1, !1) }, bl = { get: go(!0, !1) }; function mo(e, t, n) { const r = N(n); if (r !== n && t.call(e, r)) { const i = lo(e) } } var vo = new WeakMap, yl = new WeakMap, Eo = new WeakMap, Al = new WeakMap; function wl(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function Tl(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : wl(lo(e)) } function Kr(e) { return e && e.__v_isReadonly ? e : yo(e, !1, dl, El, vo) } function bo(e) { return yo(e, !0, hl, bl, Eo) } function yo(e, t, n, r, i) { if (!_n(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const s = i.get(e); if (s) return s; const o = Tl(e); if (o === 0) return e; const a = new Proxy(e, o === 2 ? r : n); return i.set(e, a), a } function N(e) { return e && N(e.__v_raw) || e } function dr(e) { return !!(e && e.__v_isRef === !0) } G("nextTick", () => Pr); G("dispatch", e => pe.bind(pe, e)); G("watch", (e, { evaluateLater: t, effect: n }) => (r, i) => { let s = t(r), o = !0, a, u = n(() => s(g => { JSON.stringify(g), o ? a = g : queueMicrotask(() => { i(g, a), a = g }), o = !1 })); e._x_effects.delete(u) }); G("store", kc); G("data", e => $s(e)); G("root", e => fn(e)); G("refs", e => (e._x_refs_proxy || (e._x_refs_proxy = Te(Sl(e))), e._x_refs_proxy)); function Sl(e) { let t = [], n = e; for (; n;)n._x_refs && t.push(n._x_refs), n = n.parentNode; return t } var Ln = {}; function Ao(e) { return Ln[e] || (Ln[e] = 0), ++Ln[e] } function Ol(e, t) { return dn(e, n => { if (n._x_ids && n._x_ids[t]) return !0 }) } function Cl(e, t) { e._x_ids || (e._x_ids = {}), e._x_ids[t] || (e._x_ids[t] = Ao(t)) } G("id", e => (t, n = null) => { let r = Ol(e, t), i = r ? r._x_ids[t] : Ao(t); return n ? `${t}-${i}-${n}` : `${t}-${i}` }); G("el", e => e); wo("Focus", "focus", "focus"); wo("Persist", "persist", "persist"); function wo(e, t, n) { G(t, r => it(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, r)) } D("modelable", (e, { expression: t }, { effect: n, evaluateLater: r, cleanup: i }) => { let s = r(t), o = () => { let _; return s(E => _ = E), _ }, a = r(`${t} = __placeholder`), u = _ => a(() => { }, { scope: { __placeholder: _ } }), g = o(); u(g), queueMicrotask(() => { if (!e._x_model) return; e._x_removeModelListeners.default(); let _ = e._x_model.get, E = e._x_model.set, b = io({ get() { return _() }, set(y) { E(y) } }, { get() { return o() }, set(y) { u(y) } }); i(b) }) }); D("teleport", (e, { modifiers: t, expression: n }, { cleanup: r }) => { e.tagName.toLowerCase() !== "template" && it("x-teleport can only be used on a <template> tag", e); let i = Ni(n), s = e.content.cloneNode(!0).firstElementChild; e._x_teleport = s, s._x_teleportBack = e, e.setAttribute("data-teleport-template", !0), s.setAttribute("data-teleport-target", !0), e._x_forwardEvents && e._x_forwardEvents.forEach(a => { s.addEventListener(a, u => { u.stopPropagation(), e.dispatchEvent(new u.constructor(u.type, u)) }) }), we(s, {}, e); let o = (a, u, g) => { g.includes("prepend") ? u.parentNode.insertBefore(a, u) : g.includes("append") ? u.parentNode.insertBefore(a, u.nextSibling) : u.appendChild(a) }; $(() => { o(s, i, t), st(s), s._x_ignore = !0 }), e._x_teleportPutBack = () => { let a = Ni(n); $(() => { o(e._x_teleport, a, t) }) }, r(() => s.remove()) }); var xl = document.createElement("div"); function Ni(e) { let t = Se(() => document.querySelector(e), () => xl)(); return t || it(`Cannot find x-teleport element for selector: "${e}"`), t } var To = () => { }; To.inline = (e, { modifiers: t }, { cleanup: n }) => { t.includes("self") ? e._x_ignoreSelf = !0 : e._x_ignore = !0, n(() => { t.includes("self") ? delete e._x_ignoreSelf : delete e._x_ignore }) }; D("ignore", To); D("effect", Se((e, { expression: t }, { effect: n }) => { n(M(e, t)) })); function hr(e, t, n, r) { let i = e, s = u => r(u), o = {}, a = (u, g) => _ => g(u, _); if (n.includes("dot") && (t = Nl(t)), n.includes("camel") && (t = Dl(t)), n.includes("passive") && (o.passive = !0), n.includes("capture") && (o.capture = !0), n.includes("window") && (i = window), n.includes("document") && (i = document), n.includes("debounce")) { let u = n[n.indexOf("debounce") + 1] || "invalid-wait", g = on(u.split("ms")[0]) ? Number(u.split("ms")[0]) : 250; s = no(s, g) } if (n.includes("throttle")) { let u = n[n.indexOf("throttle") + 1] || "invalid-wait", g = on(u.split("ms")[0]) ? Number(u.split("ms")[0]) : 250; s = ro(s, g) } return n.includes("prevent") && (s = a(s, (u, g) => { g.preventDefault(), u(g) })), n.includes("stop") && (s = a(s, (u, g) => { g.stopPropagation(), u(g) })), n.includes("self") && (s = a(s, (u, g) => { g.target === e && u(g) })), (n.includes("away") || n.includes("outside")) && (i = document, s = a(s, (u, g) => { e.contains(g.target) || g.target.isConnected !== !1 && (e.offsetWidth < 1 && e.offsetHeight < 1 || e._x_isShown !== !1 && u(g)) })), n.includes("once") && (s = a(s, (u, g) => { u(g), i.removeEventListener(t, s, o) })), s = a(s, (u, g) => { Ll(t) && Il(g, n) || u(g) }), i.addEventListener(t, s, o), () => { i.removeEventListener(t, s, o) } } function Nl(e) { return e.replace(/-/g, ".") } function Dl(e) { return e.toLowerCase().replace(/-(\w)/g, (t, n) => n.toUpperCase()) } function on(e) { return !Array.isArray(e) && !isNaN(e) } function $l(e) { return [" ", "_"].includes(e) ? e : e.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase() } function Ll(e) { return ["keydown", "keyup"].includes(e) } function Il(e, t) { let n = t.filter(s => !["window", "document", "prevent", "stop", "once", "capture"].includes(s)); if (n.includes("debounce")) { let s = n.indexOf("debounce"); n.splice(s, on((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (n.includes("throttle")) { let s = n.indexOf("throttle"); n.splice(s, on((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (n.length === 0 || n.length === 1 && Di(e.key).includes(n[0])) return !1; const i = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter(s => n.includes(s)); return n = n.filter(s => !i.includes(s)), !(i.length > 0 && i.filter(o => ((o === "cmd" || o === "super") && (o = "meta"), e[`${o}Key`])).length === i.length && Di(e.key).includes(n[0])) } function Di(e) { if (!e) return []; e = $l(e); let t = { ctrl: "control", slash: "/", space: " ", spacebar: " ", cmd: "meta", esc: "escape", up: "arrow-up", down: "arrow-down", left: "arrow-left", right: "arrow-right", period: ".", equal: "=", minus: "-", underscore: "_" }; return t[e] = e, Object.keys(t).map(n => { if (t[n] === e) return n }).filter(n => n) } D("model", (e, { modifiers: t, expression: n }, { effect: r, cleanup: i }) => { let s = e; t.includes("parent") && (s = e.parentNode); let o = M(s, n), a; typeof n == "string" ? a = M(s, `${n} = __placeholder`) : typeof n == "function" && typeof n() == "string" ? a = M(s, `${n()} = __placeholder`) : a = () => { }; let u = () => { let b; return o(y => b = y), $i(b) ? b.get() : b }, g = b => { let y; o(S => y = S), $i(y) ? y.set(b) : a(() => { }, { scope: { __placeholder: b } }) }; typeof n == "string" && e.type === "radio" && $(() => { e.hasAttribute("name") || e.setAttribute("name", n) }); var _ = e.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(e.type) || t.includes("lazy") ? "change" : "input"; let E = dt ? () => { } : hr(e, _, t, b => { g(Ml(e, t, b, u())) }); if (t.includes("fill") && ([null, ""].includes(u()) || e.type === "checkbox" && Array.isArray(u())) && e.dispatchEvent(new Event(_, {})), e._x_removeModelListeners || (e._x_removeModelListeners = {}), e._x_removeModelListeners.default = E, i(() => e._x_removeModelListeners.default()), e.form) { let b = hr(e.form, "reset", [], y => { Pr(() => e._x_model && e._x_model.set(e.value)) }); i(() => b()) } e._x_model = { get() { return u() }, set(b) { g(b) } }, e._x_forceModelUpdate = b => { b === void 0 && typeof n == "string" && n.match(/\./) && (b = ""), window.fromModel = !0, $(() => Js(e, "value", b)), delete window.fromModel }, r(() => { let b = u(); t.includes("unintrusive") && document.activeElement.isSameNode(e) || e._x_forceModelUpdate(b) }) }); function Ml(e, t, n, r) { return $(() => { if (n instanceof CustomEvent && n.detail !== void 0) return n.detail !== null && n.detail !== void 0 ? n.detail : n.target.value; if (e.type === "checkbox") if (Array.isArray(r)) { let i = null; return t.includes("number") ? i = In(n.target.value) : t.includes("boolean") ? i = Je(n.target.value) : i = n.target.value, n.target.checked ? r.concat([i]) : r.filter(s => !Pl(s, i)) } else return n.target.checked; else return e.tagName.toLowerCase() === "select" && e.multiple ? t.includes("number") ? Array.from(n.target.selectedOptions).map(i => { let s = i.value || i.text; return In(s) }) : t.includes("boolean") ? Array.from(n.target.selectedOptions).map(i => { let s = i.value || i.text; return Je(s) }) : Array.from(n.target.selectedOptions).map(i => i.value || i.text) : t.includes("number") ? In(n.target.value) : t.includes("boolean") ? Je(n.target.value) : t.includes("trim") ? n.target.value.trim() : n.target.value }) } function In(e) { let t = e ? parseFloat(e) : null; return Rl(t) ? t : e } function Pl(e, t) { return e == t } function Rl(e) { return !Array.isArray(e) && !isNaN(e) } function $i(e) { return e !== null && typeof e == "object" && typeof e.get == "function" && typeof e.set == "function" } D("cloak", e => queueMicrotask(() => $(() => e.removeAttribute(ne("cloak"))))); As(() => `[${ne("init")}]`); D("init", Se((e, { expression: t }, { evaluate: n }) => typeof t == "string" ? !!t.trim() && n(t, {}, !1) : n(t, {}, !1))); D("text", (e, { expression: t }, { effect: n, evaluateLater: r }) => { let i = r(t); n(() => { i(s => { $(() => { e.textContent = s }) }) }) }); D("html", (e, { expression: t }, { effect: n, evaluateLater: r }) => { let i = r(t); n(() => { i(s => { $(() => { e.innerHTML = s, e._x_ignoreSelf = !0, st(e), delete e._x_ignoreSelf }) }) }) }); Ir(Hs(":", js(ne("bind:")))); var So = (e, { value: t, modifiers: n, expression: r, original: i }, { effect: s }) => { if (!t) { let a = {}; Vc(a), M(e, r)(g => { oo(e, g, i) }, { scope: a }); return } if (t === "key") return Bl(e, r); if (e._x_inlineBindings && e._x_inlineBindings[t] && e._x_inlineBindings[t].extract) return; let o = M(e, r); s(() => o(a => { a === void 0 && typeof r == "string" && r.match(/\./) && (a = ""), $(() => Js(e, t, a, n)) })) }; So.inline = (e, { value: t, modifiers: n, expression: r }) => { t && (e._x_inlineBindings || (e._x_inlineBindings = {}), e._x_inlineBindings[t] = { expression: r, extract: !1 }) }; D("bind", So); function Bl(e, t) { e._x_keyExpression = t } ys(() => `[${ne("data")}]`); D("data", (e, { expression: t }, { cleanup: n }) => { if (kl(e)) return; t = t === "" ? "{}" : t; let r = {}; er(r, e); let i = {}; jc(i, r); let s = Dt(e, t, { scope: i }); (s === void 0 || s === !0) && (s = {}), er(s, e); let o = te(s); Ls(o); let a = we(e, o); o.init && Dt(e, o.init), n(() => { o.destroy && Dt(e, o.destroy), a() }) }); Xs((e, t) => { e._x_dataStack && (t._x_dataStack = e._x_dataStack, t.setAttribute("data-has-alpine-state", !0)) }); function kl(e) { return dt ? lr ? !0 : e.hasAttribute("data-has-alpine-state") : !1 } D("show", (e, { modifiers: t, expression: n }, { effect: r }) => { let i = M(e, n); e._x_doHide || (e._x_doHide = () => { $(() => { e.style.setProperty("display", "none", t.includes("important") ? "important" : void 0) }) }), e._x_doShow || (e._x_doShow = () => { $(() => { e.style.length === 1 && e.style.display === "none" ? e.removeAttribute("style") : e.style.removeProperty("display") }) }); let s = () => { e._x_doHide(), e._x_isShown = !1 }, o = () => { e._x_doShow(), e._x_isShown = !0 }, a = () => setTimeout(o), u = ar(E => E ? o() : s(), E => { typeof e._x_toggleAndCascadeWithTransitions == "function" ? e._x_toggleAndCascadeWithTransitions(e, E, o, s) : E ? a() : s() }), g, _ = !0; r(() => i(E => { !_ && E === g || (t.includes("immediate") && (E ? a() : s()), u(E), g = E, _ = !1) })) }); D("for", (e, { expression: t }, { effect: n, cleanup: r }) => { let i = Vl(t), s = M(e, i.items), o = M(e, e._x_keyExpression || "index"); e._x_prevKeys = [], e._x_lookup = {}, n(() => Fl(e, i, s, o)), r(() => { Object.values(e._x_lookup).forEach(a => a.remove()), delete e._x_prevKeys, delete e._x_lookup }) }); function Fl(e, t, n, r) { let i = o => typeof o == "object" && !Array.isArray(o), s = e; n(o => { Hl(o) && o >= 0 && (o = Array.from(Array(o).keys(), m => m + 1)), o === void 0 && (o = []); let a = e._x_lookup, u = e._x_prevKeys, g = [], _ = []; if (i(o)) o = Object.entries(o).map(([m, p]) => { let h = Li(t, p, m, o); r(l => _.push(l), { scope: { index: m, ...h } }), g.push(h) }); else for (let m = 0; m < o.length; m++) { let p = Li(t, o[m], m, o); r(h => _.push(h), { scope: { index: m, ...p } }), g.push(p) } let E = [], b = [], y = [], S = []; for (let m = 0; m < u.length; m++) { let p = u[m]; _.indexOf(p) === -1 && y.push(p) } u = u.filter(m => !y.includes(m)); let w = "template"; for (let m = 0; m < _.length; m++) { let p = _[m], h = u.indexOf(p); if (h === -1) u.splice(m, 0, p), E.push([w, m]); else if (h !== m) { let l = u.splice(m, 1)[0], c = u.splice(h - 1, 1)[0]; u.splice(m, 0, c), u.splice(h, 0, l), b.push([l, c]) } else S.push(p); w = p } for (let m = 0; m < y.length; m++) { let p = y[m]; a[p]._x_effects && a[p]._x_effects.forEach(gs), a[p].remove(), a[p] = null, delete a[p] } for (let m = 0; m < b.length; m++) { let [p, h] = b[m], l = a[p], c = a[h], d = document.createElement("div"); $(() => { c || it('x-for ":key" is undefined or invalid', s), c.after(d), l.after(c), c._x_currentIfEl && c.after(c._x_currentIfEl), d.before(l), l._x_currentIfEl && l.after(l._x_currentIfEl), d.remove() }), c._x_refreshXForScope(g[_.indexOf(h)]) } for (let m = 0; m < E.length; m++) { let [p, h] = E[m], l = p === "template" ? s : a[p]; l._x_currentIfEl && (l = l._x_currentIfEl); let c = g[h], d = _[h], f = document.importNode(s.content, !0).firstElementChild, T = te(c); we(f, T, s), f._x_refreshXForScope = O => { Object.entries(O).forEach(([C, x]) => { T[C] = x }) }, $(() => { l.after(f), st(f) }), typeof d == "object" && it("x-for key cannot be an object, it must be a string or an integer", s), a[d] = f } for (let m = 0; m < S.length; m++)a[S[m]]._x_refreshXForScope(g[_.indexOf(S[m])]); s._x_prevKeys = _ }) } function Vl(e) { let t = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, n = /^\s*\(|\)\s*$/g, r = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, i = e.match(r); if (!i) return; let s = {}; s.items = i[2].trim(); let o = i[1].replace(n, "").trim(), a = o.match(t); return a ? (s.item = o.replace(t, "").trim(), s.index = a[1].trim(), a[2] && (s.collection = a[2].trim())) : s.item = o, s } function Li(e, t, n, r) { let i = {}; return /^\[.*\]$/.test(e.item) && Array.isArray(t) ? e.item.replace("[", "").replace("]", "").split(",").map(o => o.trim()).forEach((o, a) => { i[o] = t[a] }) : /^\{.*\}$/.test(e.item) && !Array.isArray(t) && typeof t == "object" ? e.item.replace("{", "").replace("}", "").split(",").map(o => o.trim()).forEach(o => { i[o] = t[o] }) : i[e.item] = t, e.index && (i[e.index] = n), e.collection && (i[e.collection] = r), i } function Hl(e) { return !Array.isArray(e) && !isNaN(e) } function Oo() { } Oo.inline = (e, { expression: t }, { cleanup: n }) => { let r = fn(e); r._x_refs || (r._x_refs = {}), r._x_refs[t] = e, n(() => delete r._x_refs[t]) }; D("ref", Oo); D("if", (e, { expression: t }, { effect: n, cleanup: r }) => { e.tagName.toLowerCase() !== "template" && it("x-if can only be used on a <template> tag", e); let i = M(e, t), s = () => { if (e._x_currentIfEl) return e._x_currentIfEl; let a = e.content.cloneNode(!0).firstElementChild; return we(a, {}, e), $(() => { e.after(a), st(a) }), e._x_currentIfEl = a, e._x_undoIf = () => { ft(a, u => { u._x_effects && u._x_effects.forEach(gs) }), a.remove(), delete e._x_currentIfEl }, a }, o = () => { e._x_undoIf && (e._x_undoIf(), delete e._x_undoIf) }; n(() => i(a => { a ? s() : o() })), r(() => e._x_undoIf && e._x_undoIf()) }); D("id", (e, { expression: t }, { evaluate: n }) => { n(t).forEach(i => Cl(e, i)) }); Ir(Hs("@", js(ne("on:")))); D("on", Se((e, { value: t, modifiers: n, expression: r }, { cleanup: i }) => { let s = r ? M(e, r) : () => { }; e.tagName.toLowerCase() === "template" && (e._x_forwardEvents || (e._x_forwardEvents = []), e._x_forwardEvents.includes(t) || e._x_forwardEvents.push(t)); let o = hr(e, t, n, a => { s(() => { }, { scope: { $event: a }, params: [a] }) }); i(() => o()) })); mn("Collapse", "collapse", "collapse"); mn("Intersect", "intersect", "intersect"); mn("Focus", "trap", "focus"); mn("Mask", "mask", "mask"); function mn(e, t, n) { D(t, r => it(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, r)) } Oe.setEvaluator(Bs); Oe.setReactivityEngine({ reactive: Kr, effect: Qc, release: Jc, raw: N }); var jl = Oe, Ur = jl, P = "top", F = "bottom", V = "right", R = "left", vn = "auto", re = [P, F, V, R], Mt = "start", zt = "end", Co = "clippingParents", Wr = "viewport", Ht = "popper", xo = "reference", pr = re.reduce(function (e, t) { return e.concat([t + "-" + Mt, t + "-" + zt]) }, []), Yr = [].concat(re, [vn]).reduce(function (e, t) { return e.concat([t, t + "-" + Mt, t + "-" + zt]) }, []), No = "beforeRead", Do = "read", $o = "afterRead", Lo = "beforeMain", Io = "main", Mo = "afterMain", Po = "beforeWrite", Ro = "write", Bo = "afterWrite", ko = [No, Do, $o, Lo, Io, Mo, Po, Ro, Bo]; function tt(e) { return e ? (e.nodeName || "").toLowerCase() : null } function H(e) { if (e == null) return window; if (e.toString() !== "[object Window]") { var t = e.ownerDocument; return t && t.defaultView || window } return e } function Pt(e) { var t = H(e).Element; return e instanceof t || e instanceof Element } function j(e) { var t = H(e).HTMLElement; return e instanceof t || e instanceof HTMLElement } function zr(e) { if (typeof ShadowRoot == "undefined") return !1; var t = H(e).ShadowRoot; return e instanceof t || e instanceof ShadowRoot } function Kl(e) { var t = e.state; Object.keys(t.elements).forEach(function (n) { var r = t.styles[n] || {}, i = t.attributes[n] || {}, s = t.elements[n]; !j(s) || !tt(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function (o) { var a = i[o]; a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a) })) }) } function Ul(e) { var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach(function (r) { var i = t.elements[r], s = t.attributes[r] || {}, o = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), a = o.reduce(function (u, g) { return u[g] = "", u }, {}); !j(i) || !tt(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function (u) { i.removeAttribute(u) })) }) } } const qr = { name: "applyStyles", enabled: !0, phase: "write", fn: Kl, effect: Ul, requires: ["computeStyles"] }; function J(e) { return e.split("-")[0] } var It = Math.max, an = Math.min, qt = Math.round; function _r() { var e = navigator.userAgentData; return e != null && e.brands && Array.isArray(e.brands) ? e.brands.map(function (t) { return t.brand + "/" + t.version }).join(" ") : navigator.userAgent } function Fo() { return !/^((?!chrome|android).)*safari/i.test(_r()) } function Gt(e, t, n) { t === void 0 && (t = !1), n === void 0 && (n = !1); var r = e.getBoundingClientRect(), i = 1, s = 1; t && j(e) && (i = e.offsetWidth > 0 && qt(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && qt(r.height) / e.offsetHeight || 1); var o = Pt(e) ? H(e) : window, a = o.visualViewport, u = !Fo() && n, g = (r.left + (u && a ? a.offsetLeft : 0)) / i, _ = (r.top + (u && a ? a.offsetTop : 0)) / s, E = r.width / i, b = r.height / s; return { width: E, height: b, top: _, right: g + E, bottom: _ + b, left: g, x: g, y: _ } } function Gr(e) { var t = Gt(e), n = e.offsetWidth, r = e.offsetHeight; return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: r } } function Vo(e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && zr(n)) { var r = t; do { if (r && e.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function ot(e) { return H(e).getComputedStyle(e) } function Wl(e) { return ["table", "td", "th"].indexOf(tt(e)) >= 0 } function mt(e) { return ((Pt(e) ? e.ownerDocument : e.document) || window.document).documentElement } function En(e) { return tt(e) === "html" ? e : e.assignedSlot || e.parentNode || (zr(e) ? e.host : null) || mt(e) } function Ii(e) { return !j(e) || ot(e).position === "fixed" ? null : e.offsetParent } function Yl(e) { var t = /firefox/i.test(_r()), n = /Trident/i.test(_r()); if (n && j(e)) { var r = ot(e); if (r.position === "fixed") return null } var i = En(e); for (zr(i) && (i = i.host); j(i) && ["html", "body"].indexOf(tt(i)) < 0;) { var s = ot(i); if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || t && s.willChange === "filter" || t && s.filter && s.filter !== "none") return i; i = i.parentNode } return null } function Ce(e) { for (var t = H(e), n = Ii(e); n && Wl(n) && ot(n).position === "static";)n = Ii(n); return n && (tt(n) === "html" || tt(n) === "body" && ot(n).position === "static") ? t : n || Yl(e) || t } function Xr(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function me(e, t, n) { return It(e, an(t, n)) } function zl(e, t, n) { var r = me(e, t, n); return r > n ? n : r } function Ho() { return { top: 0, right: 0, bottom: 0, left: 0 } } function jo(e) { return Object.assign({}, Ho(), e) } function Ko(e, t) { return t.reduce(function (n, r) { return n[r] = e, n }, {}) } var ql = function (t, n) { return t = typeof t == "function" ? t(Object.assign({}, n.rects, { placement: n.placement })) : t, jo(typeof t != "number" ? t : Ko(t, re)) }; function Gl(e) { var t, n = e.state, r = e.name, i = e.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = J(n.placement), u = Xr(a), g = [R, V].indexOf(a) >= 0, _ = g ? "height" : "width"; if (!(!s || !o)) { var E = ql(i.padding, n), b = Gr(s), y = u === "y" ? P : R, S = u === "y" ? F : V, w = n.rects.reference[_] + n.rects.reference[u] - o[u] - n.rects.popper[_], m = o[u] - n.rects.reference[u], p = Ce(s), h = p ? u === "y" ? p.clientHeight || 0 : p.clientWidth || 0 : 0, l = w / 2 - m / 2, c = E[y], d = h - b[_] - E[S], f = h / 2 - b[_] / 2 + l, T = me(c, f, d), O = u; n.modifiersData[r] = (t = {}, t[O] = T, t.centerOffset = T - f, t) } } function Xl(e) { var t = e.state, n = e.options, r = n.element, i = r === void 0 ? "[data-popper-arrow]" : r; i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || Vo(t.elements.popper, i) && (t.elements.arrow = i)) } const Uo = { name: "arrow", enabled: !0, phase: "main", fn: Gl, effect: Xl, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Xt(e) { return e.split("-")[1] } var Ql = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function Jl(e, t) { var n = e.x, r = e.y, i = t.devicePixelRatio || 1; return { x: qt(n * i) / i || 0, y: qt(r * i) / i || 0 } } function Mi(e) { var t, n = e.popper, r = e.popperRect, i = e.placement, s = e.variation, o = e.offsets, a = e.position, u = e.gpuAcceleration, g = e.adaptive, _ = e.roundOffsets, E = e.isFixed, b = o.x, y = b === void 0 ? 0 : b, S = o.y, w = S === void 0 ? 0 : S, m = typeof _ == "function" ? _({ x: y, y: w }) : { x: y, y: w }; y = m.x, w = m.y; var p = o.hasOwnProperty("x"), h = o.hasOwnProperty("y"), l = R, c = P, d = window; if (g) { var f = Ce(n), T = "clientHeight", O = "clientWidth"; if (f === H(n) && (f = mt(n), ot(f).position !== "static" && a === "absolute" && (T = "scrollHeight", O = "scrollWidth")), f = f, i === P || (i === R || i === V) && s === zt) { c = F; var C = E && f === d && d.visualViewport ? d.visualViewport.height : f[T]; w -= C - r.height, w *= u ? 1 : -1 } if (i === R || (i === P || i === F) && s === zt) { l = V; var x = E && f === d && d.visualViewport ? d.visualViewport.width : f[O]; y -= x - r.width, y *= u ? 1 : -1 } } var L = Object.assign({ position: a }, g && Ql), Y = _ === !0 ? Jl({ x: y, y: w }, H(n)) : { x: y, y: w }; if (y = Y.x, w = Y.y, u) { var I; return Object.assign({}, L, (I = {}, I[c] = h ? "0" : "", I[l] = p ? "0" : "", I.transform = (d.devicePixelRatio || 1) <= 1 ? "translate(" + y + "px, " + w + "px)" : "translate3d(" + y + "px, " + w + "px, 0)", I)) } return Object.assign({}, L, (t = {}, t[c] = h ? w + "px" : "", t[l] = p ? y + "px" : "", t.transform = "", t)) } function Zl(e) { var t = e.state, n = e.options, r = n.gpuAcceleration, i = r === void 0 ? !0 : r, s = n.adaptive, o = s === void 0 ? !0 : s, a = n.roundOffsets, u = a === void 0 ? !0 : a, g = { placement: J(t.placement), variation: Xt(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: i, isFixed: t.options.strategy === "fixed" }; t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Mi(Object.assign({}, g, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: u })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Mi(Object.assign({}, g, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: u })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) } const Qr = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: Zl, data: {} }; var Ke = { passive: !0 }; function tu(e) { var t = e.state, n = e.instance, r = e.options, i = r.scroll, s = i === void 0 ? !0 : i, o = r.resize, a = o === void 0 ? !0 : o, u = H(t.elements.popper), g = [].concat(t.scrollParents.reference, t.scrollParents.popper); return s && g.forEach(function (_) { _.addEventListener("scroll", n.update, Ke) }), a && u.addEventListener("resize", n.update, Ke), function () { s && g.forEach(function (_) { _.removeEventListener("scroll", n.update, Ke) }), a && u.removeEventListener("resize", n.update, Ke) } } const Jr = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: tu, data: {} }; var eu = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Ze(e) { return e.replace(/left|right|bottom|top/g, function (t) { return eu[t] }) } var nu = { start: "end", end: "start" }; function Pi(e) { return e.replace(/start|end/g, function (t) { return nu[t] }) } function Zr(e) { var t = H(e), n = t.pageXOffset, r = t.pageYOffset; return { scrollLeft: n, scrollTop: r } } function ti(e) { return Gt(mt(e)).left + Zr(e).scrollLeft } function ru(e, t) { var n = H(e), r = mt(e), i = n.visualViewport, s = r.clientWidth, o = r.clientHeight, a = 0, u = 0; if (i) { s = i.width, o = i.height; var g = Fo(); (g || !g && t === "fixed") && (a = i.offsetLeft, u = i.offsetTop) } return { width: s, height: o, x: a + ti(e), y: u } } function iu(e) { var t, n = mt(e), r = Zr(e), i = (t = e.ownerDocument) == null ? void 0 : t.body, s = It(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = It(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + ti(e), u = -r.scrollTop; return ot(i || n).direction === "rtl" && (a += It(n.clientWidth, i ? i.clientWidth : 0) - s), { width: s, height: o, x: a, y: u } } function ei(e) { var t = ot(e), n = t.overflow, r = t.overflowX, i = t.overflowY; return /auto|scroll|overlay|hidden/.test(n + i + r) } function Wo(e) { return ["html", "body", "#document"].indexOf(tt(e)) >= 0 ? e.ownerDocument.body : j(e) && ei(e) ? e : Wo(En(e)) } function ve(e, t) { var n; t === void 0 && (t = []); var r = Wo(e), i = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = H(r), o = i ? [s].concat(s.visualViewport || [], ei(r) ? r : []) : r, a = t.concat(o); return i ? a : a.concat(ve(En(o))) } function gr(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function su(e, t) { var n = Gt(e, !1, t === "fixed"); return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n } function Ri(e, t, n) { return t === Wr ? gr(ru(e, n)) : Pt(t) ? su(t, n) : gr(iu(mt(e))) } function ou(e) { var t = ve(En(e)), n = ["absolute", "fixed"].indexOf(ot(e).position) >= 0, r = n && j(e) ? Ce(e) : e; return Pt(r) ? t.filter(function (i) { return Pt(i) && Vo(i, r) && tt(i) !== "body" }) : [] } function au(e, t, n, r) { var i = t === "clippingParents" ? ou(e) : [].concat(t), s = [].concat(i, [n]), o = s[0], a = s.reduce(function (u, g) { var _ = Ri(e, g, r); return u.top = It(_.top, u.top), u.right = an(_.right, u.right), u.bottom = an(_.bottom, u.bottom), u.left = It(_.left, u.left), u }, Ri(e, o, r)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function Yo(e) { var t = e.reference, n = e.element, r = e.placement, i = r ? J(r) : null, s = r ? Xt(r) : null, o = t.x + t.width / 2 - n.width / 2, a = t.y + t.height / 2 - n.height / 2, u; switch (i) { case P: u = { x: o, y: t.y - n.height }; break; case F: u = { x: o, y: t.y + t.height }; break; case V: u = { x: t.x + t.width, y: a }; break; case R: u = { x: t.x - n.width, y: a }; break; default: u = { x: t.x, y: t.y } }var g = i ? Xr(i) : null; if (g != null) { var _ = g === "y" ? "height" : "width"; switch (s) { case Mt: u[g] = u[g] - (t[_] / 2 - n[_] / 2); break; case zt: u[g] = u[g] + (t[_] / 2 - n[_] / 2); break } } return u } function Qt(e, t) { t === void 0 && (t = {}); var n = t, r = n.placement, i = r === void 0 ? e.placement : r, s = n.strategy, o = s === void 0 ? e.strategy : s, a = n.boundary, u = a === void 0 ? Co : a, g = n.rootBoundary, _ = g === void 0 ? Wr : g, E = n.elementContext, b = E === void 0 ? Ht : E, y = n.altBoundary, S = y === void 0 ? !1 : y, w = n.padding, m = w === void 0 ? 0 : w, p = jo(typeof m != "number" ? m : Ko(m, re)), h = b === Ht ? xo : Ht, l = e.rects.popper, c = e.elements[S ? h : b], d = au(Pt(c) ? c : c.contextElement || mt(e.elements.popper), u, _, o), f = Gt(e.elements.reference), T = Yo({ reference: f, element: l, strategy: "absolute", placement: i }), O = gr(Object.assign({}, l, T)), C = b === Ht ? O : f, x = { top: d.top - C.top + p.top, bottom: C.bottom - d.bottom + p.bottom, left: d.left - C.left + p.left, right: C.right - d.right + p.right }, L = e.modifiersData.offset; if (b === Ht && L) { var Y = L[i]; Object.keys(x).forEach(function (I) { var bt = [V, F].indexOf(I) >= 0 ? 1 : -1, yt = [P, F].indexOf(I) >= 0 ? "y" : "x"; x[I] += Y[yt] * bt }) } return x } function cu(e, t) { t === void 0 && (t = {}); var n = t, r = n.placement, i = n.boundary, s = n.rootBoundary, o = n.padding, a = n.flipVariations, u = n.allowedAutoPlacements, g = u === void 0 ? Yr : u, _ = Xt(r), E = _ ? a ? pr : pr.filter(function (S) { return Xt(S) === _ }) : re, b = E.filter(function (S) { return g.indexOf(S) >= 0 }); b.length === 0 && (b = E); var y = b.reduce(function (S, w) { return S[w] = Qt(e, { placement: w, boundary: i, rootBoundary: s, padding: o })[J(w)], S }, {}); return Object.keys(y).sort(function (S, w) { return y[S] - y[w] }) } function lu(e) { if (J(e) === vn) return []; var t = Ze(e); return [Pi(e), t, Pi(t)] } function uu(e) { var t = e.state, n = e.options, r = e.name; if (!t.modifiersData[r]._skip) { for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, u = n.fallbackPlacements, g = n.padding, _ = n.boundary, E = n.rootBoundary, b = n.altBoundary, y = n.flipVariations, S = y === void 0 ? !0 : y, w = n.allowedAutoPlacements, m = t.options.placement, p = J(m), h = p === m, l = u || (h || !S ? [Ze(m)] : lu(m)), c = [m].concat(l).reduce(function (kt, ct) { return kt.concat(J(ct) === vn ? cu(t, { placement: ct, boundary: _, rootBoundary: E, padding: g, flipVariations: S, allowedAutoPlacements: w }) : ct) }, []), d = t.rects.reference, f = t.rects.popper, T = new Map, O = !0, C = c[0], x = 0; x < c.length; x++) { var L = c[x], Y = J(L), I = Xt(L) === Mt, bt = [P, F].indexOf(Y) >= 0, yt = bt ? "width" : "height", k = Qt(t, { placement: L, boundary: _, rootBoundary: E, altBoundary: b, padding: g }), z = bt ? I ? V : R : I ? F : P; d[yt] > f[yt] && (z = Ze(z)); var Ie = Ze(z), At = []; if (s && At.push(k[Y] <= 0), a && At.push(k[z] <= 0, k[Ie] <= 0), At.every(function (kt) { return kt })) { C = L, O = !1; break } T.set(L, At) } if (O) for (var Me = S ? 3 : 1, Sn = function (ct) { var ce = c.find(function (Re) { var wt = T.get(Re); if (wt) return wt.slice(0, ct).every(function (On) { return On }) }); if (ce) return C = ce, "break" }, ae = Me; ae > 0; ae--) { var Pe = Sn(ae); if (Pe === "break") break } t.placement !== C && (t.modifiersData[r]._skip = !0, t.placement = C, t.reset = !0) } } const zo = { name: "flip", enabled: !0, phase: "main", fn: uu, requiresIfExists: ["offset"], data: { _skip: !1 } }; function Bi(e, t, n) { return n === void 0 && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function ki(e) { return [P, V, F, R].some(function (t) { return e[t] >= 0 }) } function fu(e) { var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, s = t.modifiersData.preventOverflow, o = Qt(t, { elementContext: "reference" }), a = Qt(t, { altBoundary: !0 }), u = Bi(o, r), g = Bi(a, i, s), _ = ki(u), E = ki(g); t.modifiersData[n] = { referenceClippingOffsets: u, popperEscapeOffsets: g, isReferenceHidden: _, hasPopperEscaped: E }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": _, "data-popper-escaped": E }) } const qo = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: fu }; function du(e, t, n) { var r = J(e), i = [R, P].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n, o = s[0], a = s[1]; return o = o || 0, a = (a || 0) * i, [R, V].indexOf(r) >= 0 ? { x: a, y: o } : { x: o, y: a } } function hu(e) { var t = e.state, n = e.options, r = e.name, i = n.offset, s = i === void 0 ? [0, 0] : i, o = Yr.reduce(function (_, E) { return _[E] = du(E, t.rects, s), _ }, {}), a = o[t.placement], u = a.x, g = a.y; t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += g), t.modifiersData[r] = o } const Go = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: hu }; function pu(e) { var t = e.state, n = e.name; t.modifiersData[n] = Yo({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) } const ni = { name: "popperOffsets", enabled: !0, phase: "read", fn: pu, data: {} }; function _u(e) { return e === "x" ? "y" : "x" } function gu(e) { var t = e.state, n = e.options, r = e.name, i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !1 : o, u = n.boundary, g = n.rootBoundary, _ = n.altBoundary, E = n.padding, b = n.tether, y = b === void 0 ? !0 : b, S = n.tetherOffset, w = S === void 0 ? 0 : S, m = Qt(t, { boundary: u, rootBoundary: g, padding: E, altBoundary: _ }), p = J(t.placement), h = Xt(t.placement), l = !h, c = Xr(p), d = _u(c), f = t.modifiersData.popperOffsets, T = t.rects.reference, O = t.rects.popper, C = typeof w == "function" ? w(Object.assign({}, t.rects, { placement: t.placement })) : w, x = typeof C == "number" ? { mainAxis: C, altAxis: C } : Object.assign({ mainAxis: 0, altAxis: 0 }, C), L = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, Y = { x: 0, y: 0 }; if (f) { if (s) { var I, bt = c === "y" ? P : R, yt = c === "y" ? F : V, k = c === "y" ? "height" : "width", z = f[c], Ie = z + m[bt], At = z - m[yt], Me = y ? -O[k] / 2 : 0, Sn = h === Mt ? T[k] : O[k], ae = h === Mt ? -O[k] : -T[k], Pe = t.elements.arrow, kt = y && Pe ? Gr(Pe) : { width: 0, height: 0 }, ct = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Ho(), ce = ct[bt], Re = ct[yt], wt = me(0, T[k], kt[k]), On = l ? T[k] / 2 - Me - wt - ce - x.mainAxis : Sn - wt - ce - x.mainAxis, Da = l ? -T[k] / 2 + Me + wt + Re + x.mainAxis : ae + wt + Re + x.mainAxis, Cn = t.elements.arrow && Ce(t.elements.arrow), $a = Cn ? c === "y" ? Cn.clientTop || 0 : Cn.clientLeft || 0 : 0, ui = (I = L == null ? void 0 : L[c]) != null ? I : 0, La = z + On - ui - $a, Ia = z + Da - ui, fi = me(y ? an(Ie, La) : Ie, z, y ? It(At, Ia) : At); f[c] = fi, Y[c] = fi - z } if (a) { var di, Ma = c === "x" ? P : R, Pa = c === "x" ? F : V, Tt = f[d], Be = d === "y" ? "height" : "width", hi = Tt + m[Ma], pi = Tt - m[Pa], xn = [P, R].indexOf(p) !== -1, _i = (di = L == null ? void 0 : L[d]) != null ? di : 0, gi = xn ? hi : Tt - T[Be] - O[Be] - _i + x.altAxis, mi = xn ? Tt + T[Be] + O[Be] - _i - x.altAxis : pi, vi = y && xn ? zl(gi, Tt, mi) : me(y ? gi : hi, Tt, y ? mi : pi); f[d] = vi, Y[d] = vi - Tt } t.modifiersData[r] = Y } } const Xo = { name: "preventOverflow", enabled: !0, phase: "main", fn: gu, requiresIfExists: ["offset"] }; function mu(e) { return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } } function vu(e) { return e === H(e) || !j(e) ? Zr(e) : mu(e) } function Eu(e) { var t = e.getBoundingClientRect(), n = qt(t.width) / e.offsetWidth || 1, r = qt(t.height) / e.offsetHeight || 1; return n !== 1 || r !== 1 } function bu(e, t, n) { n === void 0 && (n = !1); var r = j(t), i = j(t) && Eu(t), s = mt(t), o = Gt(e, i, n), a = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 }; return (r || !r && !n) && ((tt(t) !== "body" || ei(s)) && (a = vu(t)), j(t) ? (u = Gt(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : s && (u.x = ti(s))), { x: o.left + a.scrollLeft - u.x, y: o.top + a.scrollTop - u.y, width: o.width, height: o.height } } function yu(e) { var t = new Map, n = new Set, r = []; e.forEach(function (s) { t.set(s.name, s) }); function i(s) { n.add(s.name); var o = [].concat(s.requires || [], s.requiresIfExists || []); o.forEach(function (a) { if (!n.has(a)) { var u = t.get(a); u && i(u) } }), r.push(s) } return e.forEach(function (s) { n.has(s.name) || i(s) }), r } function Au(e) { var t = yu(e); return ko.reduce(function (n, r) { return n.concat(t.filter(function (i) { return i.phase === r })) }, []) } function wu(e) { var t; return function () { return t || (t = new Promise(function (n) { Promise.resolve().then(function () { t = void 0, n(e()) }) })), t } } function Tu(e) { var t = e.reduce(function (n, r) { var i = n[r.name]; return n[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, n }, {}); return Object.keys(t).map(function (n) { return t[n] }) } var Fi = { placement: "bottom", modifiers: [], strategy: "absolute" }; function Vi() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some(function (r) { return !(r && typeof r.getBoundingClientRect == "function") }) } function bn(e) { e === void 0 && (e = {}); var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, i = t.defaultOptions, s = i === void 0 ? Fi : i; return function (a, u, g) { g === void 0 && (g = s); var _ = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Fi, s), modifiersData: {}, elements: { reference: a, popper: u }, attributes: {}, styles: {} }, E = [], b = !1, y = { state: _, setOptions: function (p) { var h = typeof p == "function" ? p(_.options) : p; w(), _.options = Object.assign({}, s, _.options, h), _.scrollParents = { reference: Pt(a) ? ve(a) : a.contextElement ? ve(a.contextElement) : [], popper: ve(u) }; var l = Au(Tu([].concat(r, _.options.modifiers))); return _.orderedModifiers = l.filter(function (c) { return c.enabled }), S(), y.update() }, forceUpdate: function () { if (!b) { var p = _.elements, h = p.reference, l = p.popper; if (Vi(h, l)) { _.rects = { reference: bu(h, Ce(l), _.options.strategy === "fixed"), popper: Gr(l) }, _.reset = !1, _.placement = _.options.placement, _.orderedModifiers.forEach(function (x) { return _.modifiersData[x.name] = Object.assign({}, x.data) }); for (var c = 0; c < _.orderedModifiers.length; c++) { if (_.reset === !0) { _.reset = !1, c = -1; continue } var d = _.orderedModifiers[c], f = d.fn, T = d.options, O = T === void 0 ? {} : T, C = d.name; typeof f == "function" && (_ = f({ state: _, options: O, name: C, instance: y }) || _) } } } }, update: wu(function () { return new Promise(function (m) { y.forceUpdate(), m(_) }) }), destroy: function () { w(), b = !0 } }; if (!Vi(a, u)) return y; y.setOptions(g).then(function (m) { !b && g.onFirstUpdate && g.onFirstUpdate(m) }); function S() { _.orderedModifiers.forEach(function (m) { var p = m.name, h = m.options, l = h === void 0 ? {} : h, c = m.effect; if (typeof c == "function") { var d = c({ state: _, name: p, instance: y, options: l }), f = function () { }; E.push(d || f) } }) } function w() { E.forEach(function (m) { return m() }), E = [] } return y } } var Su = bn(), Ou = [Jr, ni, Qr, qr], Cu = bn({ defaultModifiers: Ou }), xu = [Jr, ni, Qr, qr, Go, zo, Xo, Uo, qo], ri = bn({ defaultModifiers: xu }); const Qo = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: Mo, afterRead: $o, afterWrite: Bo, applyStyles: qr, arrow: Uo, auto: vn, basePlacements: re, beforeMain: Lo, beforeRead: No, beforeWrite: Po, bottom: F, clippingParents: Co, computeStyles: Qr, createPopper: ri, createPopperBase: Su, createPopperLite: Cu, detectOverflow: Qt, end: zt, eventListeners: Jr, flip: zo, hide: qo, left: R, main: Io, modifierPhases: ko, offset: Go, placements: Yr, popper: Ht, popperGenerator: bn, popperOffsets: ni, preventOverflow: Xo, read: Do, reference: xo, right: V, start: Mt, top: P, variationPlacements: pr, viewport: Wr, write: Ro }, Symbol.toStringTag, { value: "Module" })); const ut = new Map, Mn = { set(e, t, n) { ut.has(e) || ut.set(e, new Map); const r = ut.get(e); !r.has(t) && r.size !== 0 || r.set(t, n) }, get(e, t) { return ut.has(e) && ut.get(e).get(t) || null }, remove(e, t) { if (!ut.has(e)) return; const n = ut.get(e); n.delete(t), n.size === 0 && ut.delete(e) } }, Nu = 1e6, Du = 1e3, mr = "transitionend", Jo = e => (e && window.CSS && window.CSS.escape && (e = e.replace(/#([^\s"#']+)/g, (t, n) => `#${CSS.escape(n)}`)), e), $u = e => e == null ? `${e}` : Object.prototype.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase(), Lu = e => { do e += Math.floor(Math.random() * Nu); while (document.getElementById(e)); return e }, Iu = e => { if (!e) return 0; let { transitionDuration: t, transitionDelay: n } = window.getComputedStyle(e); const r = Number.parseFloat(t), i = Number.parseFloat(n); return !r && !i ? 0 : (t = t.split(",")[0], n = n.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(n)) * Du) }, Zo = e => { e.dispatchEvent(new Event(mr)) }, nt = e => !e || typeof e != "object" ? !1 : (typeof e.jquery != "undefined" && (e = e[0]), typeof e.nodeType != "undefined"), pt = e => nt(e) ? e.jquery ? e[0] : e : typeof e == "string" && e.length > 0 ? document.querySelector(Jo(e)) : null, ie = e => { if (!nt(e) || e.getClientRects().length === 0) return !1; const t = getComputedStyle(e).getPropertyValue("visibility") === "visible", n = e.closest("details:not([open])"); if (!n) return t; if (n !== e) { const r = e.closest("summary"); if (r && r.parentNode !== n || r === null) return !1 } return t }, _t = e => !e || e.nodeType !== Node.ELEMENT_NODE || e.classList.contains("disabled") ? !0 : typeof e.disabled != "undefined" ? e.disabled : e.hasAttribute("disabled") && e.getAttribute("disabled") !== "false", ta = e => { if (!document.documentElement.attachShadow) return null; if (typeof e.getRootNode == "function") { const t = e.getRootNode(); return t instanceof ShadowRoot ? t : null } return e instanceof ShadowRoot ? e : e.parentNode ? ta(e.parentNode) : null }, cn = () => { }, xe = e => { e.offsetHeight }, ea = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, Pn = [], Mu = e => { document.readyState === "loading" ? (Pn.length || document.addEventListener("DOMContentLoaded", () => { for (const t of Pn) t() }), Pn.push(e)) : e() }, K = () => document.documentElement.dir === "rtl", W = e => { Mu(() => { const t = ea(); if (t) { const n = e.NAME, r = t.fn[n]; t.fn[n] = e.jQueryInterface, t.fn[n].Constructor = e, t.fn[n].noConflict = () => (t.fn[n] = r, e.jQueryInterface) } }) }, B = (e, t = [], n = e) => typeof e == "function" ? e(...t) : n, na = (e, t, n = !0) => { if (!n) { B(e); return } const i = Iu(t) + 5; let s = !1; const o = ({ target: a }) => { a === t && (s = !0, t.removeEventListener(mr, o), B(e)) }; t.addEventListener(mr, o), setTimeout(() => { s || Zo(t) }, i) }, ii = (e, t, n, r) => { const i = e.length; let s = e.indexOf(t); return s === -1 ? !n && r ? e[i - 1] : e[0] : (s += n ? 1 : -1, r && (s = (s + i) % i), e[Math.max(0, Math.min(s, i - 1))]) }, Pu = /[^.]*(?=\..*)\.|.*/, Ru = /\..*/, Bu = /::\d+$/, Rn = {}; let Hi = 1; const ra = { mouseenter: "mouseover", mouseleave: "mouseout" }, ku = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function ia(e, t) { return t && `${t}::${Hi++}` || e.uidEvent || Hi++ } function sa(e) { const t = ia(e); return e.uidEvent = t, Rn[t] = Rn[t] || {}, Rn[t] } function Fu(e, t) { return function n(r) { return si(r, { delegateTarget: e }), n.oneOff && v.off(e, r.type, t), t.apply(e, [r]) } } function Vu(e, t, n) { return function r(i) { const s = e.querySelectorAll(t); for (let { target: o } = i; o && o !== this; o = o.parentNode)for (const a of s) if (a === o) return si(i, { delegateTarget: o }), r.oneOff && v.off(e, i.type, t, n), n.apply(o, [i]) } } function oa(e, t, n = null) { return Object.values(e).find(r => r.callable === t && r.delegationSelector === n) } function aa(e, t, n) { const r = typeof t == "string", i = r ? n : t || n; let s = ca(e); return ku.has(s) || (s = e), [r, i, s] } function ji(e, t, n, r, i) { if (typeof t != "string" || !e) return; let [s, o, a] = aa(t, n, r); t in ra && (o = (S => function (w) { if (!w.relatedTarget || w.relatedTarget !== w.delegateTarget && !w.delegateTarget.contains(w.relatedTarget)) return S.call(this, w) })(o)); const u = sa(e), g = u[a] || (u[a] = {}), _ = oa(g, o, s ? n : null); if (_) { _.oneOff = _.oneOff && i; return } const E = ia(o, t.replace(Pu, "")), b = s ? Vu(e, n, o) : Fu(e, o); b.delegationSelector = s ? n : null, b.callable = o, b.oneOff = i, b.uidEvent = E, g[E] = b, e.addEventListener(a, b, s) } function vr(e, t, n, r, i) { const s = oa(t[n], r, i); s && (e.removeEventListener(n, s, !!i), delete t[n][s.uidEvent]) } function Hu(e, t, n, r) { const i = t[n] || {}; for (const [s, o] of Object.entries(i)) s.includes(r) && vr(e, t, n, o.callable, o.delegationSelector) } function ca(e) { return e = e.replace(Ru, ""), ra[e] || e } const v = { on(e, t, n, r) { ji(e, t, n, r, !1) }, one(e, t, n, r) { ji(e, t, n, r, !0) }, off(e, t, n, r) { if (typeof t != "string" || !e) return; const [i, s, o] = aa(t, n, r), a = o !== t, u = sa(e), g = u[o] || {}, _ = t.startsWith("."); if (typeof s != "undefined") { if (!Object.keys(g).length) return; vr(e, u, o, s, i ? n : null); return } if (_) for (const E of Object.keys(u)) Hu(e, u, E, t.slice(1)); for (const [E, b] of Object.entries(g)) { const y = E.replace(Bu, ""); (!a || t.includes(y)) && vr(e, u, o, b.callable, b.delegationSelector) } }, trigger(e, t, n) { if (typeof t != "string" || !e) return null; const r = ea(), i = ca(t), s = t !== i; let o = null, a = !0, u = !0, g = !1; s && r && (o = r.Event(t, n), r(e).trigger(o), a = !o.isPropagationStopped(), u = !o.isImmediatePropagationStopped(), g = o.isDefaultPrevented()); const _ = si(new Event(t, { bubbles: a, cancelable: !0 }), n); return g && _.preventDefault(), u && e.dispatchEvent(_), _.defaultPrevented && o && o.preventDefault(), _ } }; function si(e, t = {}) { for (const [n, r] of Object.entries(t)) try { e[n] = r } catch { Object.defineProperty(e, n, { configurable: !0, get() { return r } }) } return e } function Ki(e) { if (e === "true") return !0; if (e === "false") return !1; if (e === Number(e).toString()) return Number(e); if (e === "" || e === "null") return null; if (typeof e != "string") return e; try { return JSON.parse(decodeURIComponent(e)) } catch { return e } } function Bn(e) { return e.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`) } const rt = { setDataAttribute(e, t, n) { e.setAttribute(`data-bs-${Bn(t)}`, n) }, removeDataAttribute(e, t) { e.removeAttribute(`data-bs-${Bn(t)}`) }, getDataAttributes(e) { if (!e) return {}; const t = {}, n = Object.keys(e.dataset).filter(r => r.startsWith("bs") && !r.startsWith("bsConfig")); for (const r of n) { let i = r.replace(/^bs/, ""); i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = Ki(e.dataset[r]) } return t }, getDataAttribute(e, t) { return Ki(e.getAttribute(`data-bs-${Bn(t)}`)) } }; class Ne { static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } _getConfig(t) { return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } _configAfterMerge(t) { return t } _mergeConfigObj(t, n) { const r = nt(n) ? rt.getDataAttribute(n, "config") : {}; return { ...this.constructor.Default, ...typeof r == "object" ? r : {}, ...nt(n) ? rt.getDataAttributes(n) : {}, ...typeof t == "object" ? t : {} } } _typeCheckConfig(t, n = this.constructor.DefaultType) { for (const [r, i] of Object.entries(n)) { const s = t[r], o = nt(s) ? "element" : $u(s); if (!new RegExp(i).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${r}" provided type "${o}" but expected type "${i}".`) } } } const ju = "5.3.2"; class X extends Ne { constructor(t, n) { super(), t = pt(t), t && (this._element = t, this._config = this._getConfig(n), Mn.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { Mn.remove(this._element, this.constructor.DATA_KEY), v.off(this._element, this.constructor.EVENT_KEY); for (const t of Object.getOwnPropertyNames(this)) this[t] = null } _queueCallback(t, n, r = !0) { na(t, n, r) } _getConfig(t) { return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } static getInstance(t) { return Mn.get(pt(t), this.DATA_KEY) } static getOrCreateInstance(t, n = {}) { return this.getInstance(t) || new this(t, typeof n == "object" ? n : null) } static get VERSION() { return ju } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } static eventName(t) { return `${t}${this.EVENT_KEY}` } } const kn = e => { let t = e.getAttribute("data-bs-target"); if (!t || t === "#") { let n = e.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), t = n && n !== "#" ? Jo(n.trim()) : null } return t }, A = { find(e, t = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(t, e)) }, findOne(e, t = document.documentElement) { return Element.prototype.querySelector.call(t, e) }, children(e, t) { return [].concat(...e.children).filter(n => n.matches(t)) }, parents(e, t) { const n = []; let r = e.parentNode.closest(t); for (; r;)n.push(r), r = r.parentNode.closest(t); return n }, prev(e, t) { let n = e.previousElementSibling; for (; n;) { if (n.matches(t)) return [n]; n = n.previousElementSibling } return [] }, next(e, t) { let n = e.nextElementSibling; for (; n;) { if (n.matches(t)) return [n]; n = n.nextElementSibling } return [] }, focusableChildren(e) { const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(n => `${n}:not([tabindex^="-"])`).join(","); return this.find(t, e).filter(n => !_t(n) && ie(n)) }, getSelectorFromElement(e) { const t = kn(e); return t && A.findOne(t) ? t : null }, getElementFromSelector(e) { const t = kn(e); return t ? A.findOne(t) : null }, getMultipleElementsFromSelector(e) { const t = kn(e); return t ? A.find(t) : [] } }, yn = (e, t = "hide") => { const n = `click.dismiss${e.EVENT_KEY}`, r = e.NAME; v.on(document, n, `[data-bs-dismiss="${r}"]`, function (i) { if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), _t(this)) return; const s = A.getElementFromSelector(this) || this.closest(`.${r}`); e.getOrCreateInstance(s)[t]() }) }, Ku = "alert", Uu = "bs.alert", la = `.${Uu}`, Wu = `close${la}`, Yu = `closed${la}`, zu = "fade", qu = "show"; class De extends X { static get NAME() { return Ku } close() { if (v.trigger(this._element, Wu).defaultPrevented) return; this._element.classList.remove(qu); const n = this._element.classList.contains(zu); this._queueCallback(() => this._destroyElement(), this._element, n) } _destroyElement() { this._element.remove(), v.trigger(this._element, Yu), this.dispose() } static jQueryInterface(t) { return this.each(function () { const n = De.getOrCreateInstance(this); if (typeof t == "string") { if (n[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); n[t](this) } }) } } yn(De, "close"); W(De); const Gu = "button", Xu = "bs.button", Qu = `.${Xu}`, Ju = ".data-api", Zu = "active", Ui = '[data-bs-toggle="button"]', tf = `click${Qu}${Ju}`; class An extends X { static get NAME() { return Gu } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle(Zu)) } static jQueryInterface(t) { return this.each(function () { const n = An.getOrCreateInstance(this); t === "toggle" && n[t]() }) } } v.on(document, tf, Ui, e => { e.preventDefault(); const t = e.target.closest(Ui); An.getOrCreateInstance(t).toggle() }); W(An); const ef = "swipe", se = ".bs.swipe", nf = `touchstart${se}`, rf = `touchmove${se}`, sf = `touchend${se}`, of = `pointerdown${se}`, af = `pointerup${se}`, cf = "touch", lf = "pen", uf = "pointer-event", ff = 40, df = { endCallback: null, leftCallback: null, rightCallback: null }, hf = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }; class ln extends Ne { constructor(t, n) { super(), this._element = t, !(!t || !ln.isSupported()) && (this._config = this._getConfig(n), this._deltaX = 0, this._supportPointerEvents = !!window.PointerEvent, this._initEvents()) } static get Default() { return df } static get DefaultType() { return hf } static get NAME() { return ef } dispose() { v.off(this._element, se) } _start(t) { if (!this._supportPointerEvents) { this._deltaX = t.touches[0].clientX; return } this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) } _end(t) { this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), B(this._config.endCallback) } _move(t) { this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX } _handleSwipe() { const t = Math.abs(this._deltaX); if (t <= ff) return; const n = t / this._deltaX; this._deltaX = 0, n && B(n > 0 ? this._config.rightCallback : this._config.leftCallback) } _initEvents() { this._supportPointerEvents ? (v.on(this._element, of, t => this._start(t)), v.on(this._element, af, t => this._end(t)), this._element.classList.add(uf)) : (v.on(this._element, nf, t => this._start(t)), v.on(this._element, rf, t => this._move(t)), v.on(this._element, sf, t => this._end(t))) } _eventIsPointerPenTouch(t) { return this._supportPointerEvents && (t.pointerType === lf || t.pointerType === cf) } static isSupported() { return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0 } } const pf = "carousel", _f = "bs.carousel", vt = `.${_f}`, ua = ".data-api", gf = "ArrowLeft", mf = "ArrowRight", vf = 500, fe = "next", Ft = "prev", jt = "left", tn = "right", Ef = `slide${vt}`, Fn = `slid${vt}`, bf = `keydown${vt}`, yf = `mouseenter${vt}`, Af = `mouseleave${vt}`, wf = `dragstart${vt}`, Tf = `load${vt}${ua}`, Sf = `click${vt}${ua}`, fa = "carousel", Ue = "active", Of = "slide", Cf = "carousel-item-end", xf = "carousel-item-start", Nf = "carousel-item-next", Df = "carousel-item-prev", da = ".active", ha = ".carousel-item", $f = da + ha, Lf = ".carousel-item img", If = ".carousel-indicators", Mf = "[data-bs-slide], [data-bs-slide-to]", Pf = '[data-bs-ride="carousel"]', Rf = { [gf]: tn, [mf]: jt }, Bf = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 }, kf = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" }; class $e extends X { constructor(t, n) { super(t, n), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = A.findOne(If, this._element), this._addEventListeners(), this._config.ride === fa && this.cycle() } static get Default() { return Bf } static get DefaultType() { return kf } static get NAME() { return pf } next() { this._slide(fe) } nextWhenVisible() { !document.hidden && ie(this._element) && this.next() } prev() { this._slide(Ft) } pause() { this._isSliding && Zo(this._element), this._clearInterval() } cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval) } _maybeEnableCycle() { if (this._config.ride) { if (this._isSliding) { v.one(this._element, Fn, () => this.cycle()); return } this.cycle() } } to(t) { const n = this._getItems(); if (t > n.length - 1 || t < 0) return; if (this._isSliding) { v.one(this._element, Fn, () => this.to(t)); return } const r = this._getItemIndex(this._getActive()); if (r === t) return; const i = t > r ? fe : Ft; this._slide(i, n[t]) } dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() } _configAfterMerge(t) { return t.defaultInterval = t.interval, t } _addEventListeners() { this._config.keyboard && v.on(this._element, bf, t => this._keydown(t)), this._config.pause === "hover" && (v.on(this._element, yf, () => this.pause()), v.on(this._element, Af, () => this._maybeEnableCycle())), this._config.touch && ln.isSupported() && this._addTouchEventListeners() } _addTouchEventListeners() { for (const r of A.find(Lf, this._element)) v.on(r, wf, i => i.preventDefault()); const n = { leftCallback: () => this._slide(this._directionToOrder(jt)), rightCallback: () => this._slide(this._directionToOrder(tn)), endCallback: () => { this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), vf + this._config.interval)) } }; this._swipeHelper = new ln(this._element, n) } _keydown(t) { if (/input|textarea/i.test(t.target.tagName)) return; const n = Rf[t.key]; n && (t.preventDefault(), this._slide(this._directionToOrder(n))) } _getItemIndex(t) { return this._getItems().indexOf(t) } _setActiveIndicatorElement(t) { if (!this._indicatorsElement) return; const n = A.findOne(da, this._indicatorsElement); n.classList.remove(Ue), n.removeAttribute("aria-current"); const r = A.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement); r && (r.classList.add(Ue), r.setAttribute("aria-current", "true")) } _updateInterval() { const t = this._activeElement || this._getActive(); if (!t) return; const n = Number.parseInt(t.getAttribute("data-bs-interval"), 10); this._config.interval = n || this._config.defaultInterval } _slide(t, n = null) { if (this._isSliding) return; const r = this._getActive(), i = t === fe, s = n || ii(this._getItems(), r, i, this._config.wrap); if (s === r) return; const o = this._getItemIndex(s), a = y => v.trigger(this._element, y, { relatedTarget: s, direction: this._orderToDirection(t), from: this._getItemIndex(r), to: o }); if (a(Ef).defaultPrevented || !r || !s) return; const g = !!this._interval; this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s; const _ = i ? xf : Cf, E = i ? Nf : Df; s.classList.add(E), xe(s), r.classList.add(_), s.classList.add(_); const b = () => { s.classList.remove(_, E), s.classList.add(Ue), r.classList.remove(Ue, E, _), this._isSliding = !1, a(Fn) }; this._queueCallback(b, r, this._isAnimated()), g && this.cycle() } _isAnimated() { return this._element.classList.contains(Of) } _getActive() { return A.findOne($f, this._element) } _getItems() { return A.find(ha, this._element) } _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) } _directionToOrder(t) { return K() ? t === jt ? Ft : fe : t === jt ? fe : Ft } _orderToDirection(t) { return K() ? t === Ft ? jt : tn : t === Ft ? tn : jt } static jQueryInterface(t) { return this.each(function () { const n = $e.getOrCreateInstance(this, t); if (typeof t == "number") { n.to(t); return } if (typeof t == "string") { if (n[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); n[t]() } }) } } v.on(document, Sf, Mf, function (e) { const t = A.getElementFromSelector(this); if (!t || !t.classList.contains(fa)) return; e.preventDefault(); const n = $e.getOrCreateInstance(t), r = this.getAttribute("data-bs-slide-to"); if (r) { n.to(r), n._maybeEnableCycle(); return } if (rt.getDataAttribute(this, "slide") === "next") { n.next(), n._maybeEnableCycle(); return } n.prev(), n._maybeEnableCycle() }); v.on(window, Tf, () => { const e = A.find(Pf); for (const t of e) $e.getOrCreateInstance(t) }); W($e); const Ff = "collapse", Vf = "bs.collapse", Le = `.${Vf}`, Hf = ".data-api", jf = `show${Le}`, Kf = `shown${Le}`, Uf = `hide${Le}`, Wf = `hidden${Le}`, Yf = `click${Le}${Hf}`, Vn = "show", Ut = "collapse", We = "collapsing", zf = "collapsed", qf = `:scope .${Ut} .${Ut}`, Gf = "collapse-horizontal", Xf = "width", Qf = "height", Jf = ".collapse.show, .collapse.collapsing", Er = '[data-bs-toggle="collapse"]', Zf = { parent: null, toggle: !0 }, td = { parent: "(null|element)", toggle: "boolean" }; class ye extends X { constructor(t, n) { super(t, n), this._isTransitioning = !1, this._triggerArray = []; const r = A.find(Er); for (const i of r) { const s = A.getSelectorFromElement(i), o = A.find(s).filter(a => a === this._element); s !== null && o.length && this._triggerArray.push(i) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return Zf } static get DefaultType() { return td } static get NAME() { return Ff } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let t = []; if (this._config.parent && (t = this._getFirstLevelChildren(Jf).filter(a => a !== this._element).map(a => ye.getOrCreateInstance(a, { toggle: !1 }))), t.length && t[0]._isTransitioning || v.trigger(this._element, jf).defaultPrevented) return; for (const a of t) a.hide(); const r = this._getDimension(); this._element.classList.remove(Ut), this._element.classList.add(We), this._element.style[r] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const i = () => { this._isTransitioning = !1, this._element.classList.remove(We), this._element.classList.add(Ut, Vn), this._element.style[r] = "", v.trigger(this._element, Kf) }, o = `scroll${r[0].toUpperCase() + r.slice(1)}`; this._queueCallback(i, this._element, !0), this._element.style[r] = `${this._element[o]}px` } hide() { if (this._isTransitioning || !this._isShown() || v.trigger(this._element, Uf).defaultPrevented) return; const n = this._getDimension(); this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, xe(this._element), this._element.classList.add(We), this._element.classList.remove(Ut, Vn); for (const i of this._triggerArray) { const s = A.getElementFromSelector(i); s && !this._isShown(s) && this._addAriaAndCollapsedClass([i], !1) } this._isTransitioning = !0; const r = () => { this._isTransitioning = !1, this._element.classList.remove(We), this._element.classList.add(Ut), v.trigger(this._element, Wf) }; this._element.style[n] = "", this._queueCallback(r, this._element, !0) } _isShown(t = this._element) { return t.classList.contains(Vn) } _configAfterMerge(t) { return t.toggle = !!t.toggle, t.parent = pt(t.parent), t } _getDimension() { return this._element.classList.contains(Gf) ? Xf : Qf } _initializeChildren() { if (!this._config.parent) return; const t = this._getFirstLevelChildren(Er); for (const n of t) { const r = A.getElementFromSelector(n); r && this._addAriaAndCollapsedClass([n], this._isShown(r)) } } _getFirstLevelChildren(t) { const n = A.find(qf, this._config.parent); return A.find(t, this._config.parent).filter(r => !n.includes(r)) } _addAriaAndCollapsedClass(t, n) { if (t.length) for (const r of t) r.classList.toggle(zf, !n), r.setAttribute("aria-expanded", n) } static jQueryInterface(t) { const n = {}; return typeof t == "string" && /show|hide/.test(t) && (n.toggle = !1), this.each(function () { const r = ye.getOrCreateInstance(this, n); if (typeof t == "string") { if (typeof r[t] == "undefined") throw new TypeError(`No method named "${t}"`); r[t]() } }) } } v.on(document, Yf, Er, function (e) { (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault(); for (const t of A.getMultipleElementsFromSelector(this)) ye.getOrCreateInstance(t, { toggle: !1 }).toggle() }); W(ye); const Wi = "dropdown", ed = "bs.dropdown", Rt = `.${ed}`, oi = ".data-api", nd = "Escape", Yi = "Tab", rd = "ArrowUp", zi = "ArrowDown", id = 2, sd = `hide${Rt}`, od = `hidden${Rt}`, ad = `show${Rt}`, cd = `shown${Rt}`, pa = `click${Rt}${oi}`, _a = `keydown${Rt}${oi}`, ld = `keyup${Rt}${oi}`, Kt = "show", ud = "dropup", fd = "dropend", dd = "dropstart", hd = "dropup-center", pd = "dropdown-center", Ct = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', _d = `${Ct}.${Kt}`, en = ".dropdown-menu", gd = ".navbar", md = ".navbar-nav", vd = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", Ed = K() ? "top-end" : "top-start", bd = K() ? "top-start" : "top-end", yd = K() ? "bottom-end" : "bottom-start", Ad = K() ? "bottom-start" : "bottom-end", wd = K() ? "left-start" : "right-start", Td = K() ? "right-start" : "left-start", Sd = "top", Od = "bottom", Cd = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, xd = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" }; class Z extends X { constructor(t, n) { super(t, n), this._popper = null, this._parent = this._element.parentNode, this._menu = A.next(this._element, en)[0] || A.prev(this._element, en)[0] || A.findOne(en, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return Cd } static get DefaultType() { return xd } static get NAME() { return Wi } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (_t(this._element) || this._isShown()) return; const t = { relatedTarget: this._element }; if (!v.trigger(this._element, ad, t).defaultPrevented) { if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(md)) for (const r of [].concat(...document.body.children)) v.on(r, "mouseover", cn); this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Kt), this._element.classList.add(Kt), v.trigger(this._element, cd, t) } } hide() { if (_t(this._element) || !this._isShown()) return; const t = { relatedTarget: this._element }; this._completeHide(t) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(t) { if (!v.trigger(this._element, sd, t).defaultPrevented) { if ("ontouchstart" in document.documentElement) for (const r of [].concat(...document.body.children)) v.off(r, "mouseover", cn); this._popper && this._popper.destroy(), this._menu.classList.remove(Kt), this._element.classList.remove(Kt), this._element.setAttribute("aria-expanded", "false"), rt.removeDataAttribute(this._menu, "popper"), v.trigger(this._element, od, t) } } _getConfig(t) { if (t = super._getConfig(t), typeof t.reference == "object" && !nt(t.reference) && typeof t.reference.getBoundingClientRect != "function") throw new TypeError(`${Wi.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t } _createPopper() { if (typeof Qo == "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let t = this._element; this._config.reference === "parent" ? t = this._parent : nt(this._config.reference) ? t = pt(this._config.reference) : typeof this._config.reference == "object" && (t = this._config.reference); const n = this._getPopperConfig(); this._popper = ri(t, this._menu, n) } _isShown() { return this._menu.classList.contains(Kt) } _getPlacement() { const t = this._parent; if (t.classList.contains(fd)) return wd; if (t.classList.contains(dd)) return Td; if (t.classList.contains(hd)) return Sd; if (t.classList.contains(pd)) return Od; const n = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"; return t.classList.contains(ud) ? n ? bd : Ed : n ? Ad : yd } _detectNavbar() { return this._element.closest(gd) !== null } _getOffset() { const { offset: t } = this._config; return typeof t == "string" ? t.split(",").map(n => Number.parseInt(n, 10)) : typeof t == "function" ? n => t(n, this._element) : t } _getPopperConfig() { const t = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return (this._inNavbar || this._config.display === "static") && (rt.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...t, ...B(this._config.popperConfig, [t]) } } _selectMenuItem({ key: t, target: n }) { const r = A.find(vd, this._menu).filter(i => ie(i)); r.length && ii(r, n, t === zi, !r.includes(n)).focus() } static jQueryInterface(t) { return this.each(function () { const n = Z.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof n[t] == "undefined") throw new TypeError(`No method named "${t}"`); n[t]() } }) } static clearMenus(t) { if (t.button === id || t.type === "keyup" && t.key !== Yi) return; const n = A.find(_d); for (const r of n) { const i = Z.getInstance(r); if (!i || i._config.autoClose === !1) continue; const s = t.composedPath(), o = s.includes(i._menu); if (s.includes(i._element) || i._config.autoClose === "inside" && !o || i._config.autoClose === "outside" && o || i._menu.contains(t.target) && (t.type === "keyup" && t.key === Yi || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; const a = { relatedTarget: i._element }; t.type === "click" && (a.clickEvent = t), i._completeHide(a) } } static dataApiKeydownHandler(t) { const n = /input|textarea/i.test(t.target.tagName), r = t.key === nd, i = [rd, zi].includes(t.key); if (!i && !r || n && !r) return; t.preventDefault(); const s = this.matches(Ct) ? this : A.prev(this, Ct)[0] || A.next(this, Ct)[0] || A.findOne(Ct, t.delegateTarget.parentNode), o = Z.getOrCreateInstance(s); if (i) { t.stopPropagation(), o.show(), o._selectMenuItem(t); return } o._isShown() && (t.stopPropagation(), o.hide(), s.focus()) } } v.on(document, _a, Ct, Z.dataApiKeydownHandler); v.on(document, _a, en, Z.dataApiKeydownHandler); v.on(document, pa, Z.clearMenus); v.on(document, ld, Z.clearMenus); v.on(document, pa, Ct, function (e) { e.preventDefault(), Z.getOrCreateInstance(this).toggle() }); W(Z); const ga = "backdrop", Nd = "fade", qi = "show", Gi = `mousedown.bs.${ga}`, Dd = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" }, $d = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" }; class ma extends Ne { constructor(t) { super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null } static get Default() { return Dd } static get DefaultType() { return $d } static get NAME() { return ga } show(t) { if (!this._config.isVisible) { B(t); return } this._append(); const n = this._getElement(); this._config.isAnimated && xe(n), n.classList.add(qi), this._emulateAnimation(() => { B(t) }) } hide(t) { if (!this._config.isVisible) { B(t); return } this._getElement().classList.remove(qi), this._emulateAnimation(() => { this.dispose(), B(t) }) } dispose() { this._isAppended && (v.off(this._element, Gi), this._element.remove(), this._isAppended = !1) } _getElement() { if (!this._element) { const t = document.createElement("div"); t.className = this._config.className, this._config.isAnimated && t.classList.add(Nd), this._element = t } return this._element } _configAfterMerge(t) { return t.rootElement = pt(t.rootElement), t } _append() { if (this._isAppended) return; const t = this._getElement(); this._config.rootElement.append(t), v.on(t, Gi, () => { B(this._config.clickCallback) }), this._isAppended = !0 } _emulateAnimation(t) { na(t, this._getElement(), this._config.isAnimated) } } const Ld = "focustrap", Id = "bs.focustrap", un = `.${Id}`, Md = `focusin${un}`, Pd = `keydown.tab${un}`, Rd = "Tab", Bd = "forward", Xi = "backward", kd = { autofocus: !0, trapElement: null }, Fd = { autofocus: "boolean", trapElement: "element" }; class va extends Ne { constructor(t) { super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return kd } static get DefaultType() { return Fd } static get NAME() { return Ld } activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), v.off(document, un), v.on(document, Md, t => this._handleFocusin(t)), v.on(document, Pd, t => this._handleKeydown(t)), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, v.off(document, un)) } _handleFocusin(t) { const { trapElement: n } = this._config; if (t.target === document || t.target === n || n.contains(t.target)) return; const r = A.focusableChildren(n); r.length === 0 ? n.focus() : this._lastTabNavDirection === Xi ? r[r.length - 1].focus() : r[0].focus() } _handleKeydown(t) { t.key === Rd && (this._lastTabNavDirection = t.shiftKey ? Xi : Bd) } } const Qi = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Ji = ".sticky-top", Ye = "padding-right", Zi = "margin-right"; class br { constructor() { this._element = document.body } getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t) } hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, Ye, n => n + t), this._setElementAttributes(Qi, Ye, n => n + t), this._setElementAttributes(Ji, Zi, n => n - t) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Ye), this._resetElementAttributes(Qi, Ye), this._resetElementAttributes(Ji, Zi) } isOverflowing() { return this.getWidth() > 0 } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(t, n, r) { const i = this.getWidth(), s = o => { if (o !== this._element && window.innerWidth > o.clientWidth + i) return; this._saveInitialAttribute(o, n); const a = window.getComputedStyle(o).getPropertyValue(n); o.style.setProperty(n, `${r(Number.parseFloat(a))}px`) }; this._applyManipulationCallback(t, s) } _saveInitialAttribute(t, n) { const r = t.style.getPropertyValue(n); r && rt.setDataAttribute(t, n, r) } _resetElementAttributes(t, n) { const r = i => { const s = rt.getDataAttribute(i, n); if (s === null) { i.style.removeProperty(n); return } rt.removeDataAttribute(i, n), i.style.setProperty(n, s) }; this._applyManipulationCallback(t, r) } _applyManipulationCallback(t, n) { if (nt(t)) { n(t); return } for (const r of A.find(t, this._element)) n(r) } } const Vd = "modal", Hd = "bs.modal", U = `.${Hd}`, jd = ".data-api", Kd = "Escape", Ud = `hide${U}`, Wd = `hidePrevented${U}`, Ea = `hidden${U}`, ba = `show${U}`, Yd = `shown${U}`, zd = `resize${U}`, qd = `click.dismiss${U}`, Gd = `mousedown.dismiss${U}`, Xd = `keydown.dismiss${U}`, Qd = `click${U}${jd}`, ts = "modal-open", Jd = "fade", es = "show", Hn = "modal-static", Zd = ".modal.show", th = ".modal-dialog", eh = ".modal-body", nh = '[data-bs-toggle="modal"]', rh = { backdrop: !0, focus: !0, keyboard: !0 }, ih = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }; class Jt extends X { constructor(t, n) { super(t, n), this._dialog = A.findOne(th, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new br, this._addEventListeners() } static get Default() { return rh } static get DefaultType() { return ih } static get NAME() { return Vd } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { this._isShown || this._isTransitioning || v.trigger(this._element, ba, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(ts), this._adjustDialog(), this._backdrop.show(() => this._showElement(t))) } hide() { !this._isShown || this._isTransitioning || v.trigger(this._element, Ud).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(es), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())) } dispose() { v.off(window, U), v.off(this._dialog, U), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new ma({ isVisible: !!this._config.backdrop, isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new va({ trapElement: this._element }) } _showElement(t) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0; const n = A.findOne(eh, this._dialog); n && (n.scrollTop = 0), xe(this._element), this._element.classList.add(es); const r = () => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, v.trigger(this._element, Yd, { relatedTarget: t }) }; this._queueCallback(r, this._dialog, this._isAnimated()) } _addEventListeners() { v.on(this._element, Xd, t => { if (t.key === Kd) { if (this._config.keyboard) { this.hide(); return } this._triggerBackdropTransition() } }), v.on(window, zd, () => { this._isShown && !this._isTransitioning && this._adjustDialog() }), v.on(this._element, Gd, t => { v.one(this._element, qd, n => { if (!(this._element !== t.target || this._element !== n.target)) { if (this._config.backdrop === "static") { this._triggerBackdropTransition(); return } this._config.backdrop && this.hide() } }) }) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(ts), this._resetAdjustments(), this._scrollBar.reset(), v.trigger(this._element, Ea) }) } _isAnimated() { return this._element.classList.contains(Jd) } _triggerBackdropTransition() { if (v.trigger(this._element, Wd).defaultPrevented) return; const n = this._element.scrollHeight > document.documentElement.clientHeight, r = this._element.style.overflowY; r === "hidden" || this._element.classList.contains(Hn) || (n || (this._element.style.overflowY = "hidden"), this._element.classList.add(Hn), this._queueCallback(() => { this._element.classList.remove(Hn), this._queueCallback(() => { this._element.style.overflowY = r }, this._dialog) }, this._dialog), this._element.focus()) } _adjustDialog() { const t = this._element.scrollHeight > document.documentElement.clientHeight, n = this._scrollBar.getWidth(), r = n > 0; if (r && !t) { const i = K() ? "paddingLeft" : "paddingRight"; this._element.style[i] = `${n}px` } if (!r && t) { const i = K() ? "paddingRight" : "paddingLeft"; this._element.style[i] = `${n}px` } } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(t, n) { return this.each(function () { const r = Jt.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof r[t] == "undefined") throw new TypeError(`No method named "${t}"`); r[t](n) } }) } } v.on(document, Qd, nh, function (e) { const t = A.getElementFromSelector(this);["A", "AREA"].includes(this.tagName) && e.preventDefault(), v.one(t, ba, i => { i.defaultPrevented || v.one(t, Ea, () => { ie(this) && this.focus() }) }); const n = A.findOne(Zd); n && Jt.getInstance(n).hide(), Jt.getOrCreateInstance(t).toggle(this) }); yn(Jt); W(Jt); const sh = "offcanvas", oh = "bs.offcanvas", at = `.${oh}`, ya = ".data-api", ah = `load${at}${ya}`, ch = "Escape", ns = "show", rs = "showing", is = "hiding", lh = "offcanvas-backdrop", Aa = ".offcanvas.show", uh = `show${at}`, fh = `shown${at}`, dh = `hide${at}`, ss = `hidePrevented${at}`, wa = `hidden${at}`, hh = `resize${at}`, ph = `click${at}${ya}`, _h = `keydown.dismiss${at}`, gh = '[data-bs-toggle="offcanvas"]', mh = { backdrop: !0, keyboard: !0, scroll: !1 }, vh = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }; class gt extends X { constructor(t, n) { super(t, n), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return mh } static get DefaultType() { return vh } static get NAME() { return sh } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { if (this._isShown || v.trigger(this._element, uh, { relatedTarget: t }).defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || new br().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(rs); const r = () => { (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(ns), this._element.classList.remove(rs), v.trigger(this._element, fh, { relatedTarget: t }) }; this._queueCallback(r, this._element, !0) } hide() { if (!this._isShown || v.trigger(this._element, dh).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(is), this._backdrop.hide(); const n = () => { this._element.classList.remove(ns, is), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new br().reset(), v.trigger(this._element, wa) }; this._queueCallback(n, this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _initializeBackDrop() { const t = () => { if (this._config.backdrop === "static") { v.trigger(this._element, ss); return } this.hide() }, n = !!this._config.backdrop; return new ma({ className: lh, isVisible: n, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: n ? t : null }) } _initializeFocusTrap() { return new va({ trapElement: this._element }) } _addEventListeners() { v.on(this._element, _h, t => { if (t.key === ch) { if (this._config.keyboard) { this.hide(); return } v.trigger(this._element, ss) } }) } static jQueryInterface(t) { return this.each(function () { const n = gt.getOrCreateInstance(this, t); if (typeof t == "string") { if (n[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); n[t](this) } }) } } v.on(document, ph, gh, function (e) { const t = A.getElementFromSelector(this); if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), _t(this)) return; v.one(t, wa, () => { ie(this) && this.focus() }); const n = A.findOne(Aa); n && n !== t && gt.getInstance(n).hide(), gt.getOrCreateInstance(t).toggle(this) }); v.on(window, ah, () => { for (const e of A.find(Aa)) gt.getOrCreateInstance(e).show() }); v.on(window, hh, () => { for (const e of A.find("[aria-modal][class*=show][class*=offcanvas-]")) getComputedStyle(e).position !== "fixed" && gt.getOrCreateInstance(e).hide() }); yn(gt); W(gt); const Eh = /^aria-[\w-]*$/i, Ta = { "*": ["class", "dir", "id", "lang", "role", Eh], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, bh = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), yh = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Ah = (e, t) => { const n = e.nodeName.toLowerCase(); return t.includes(n) ? bh.has(n) ? !!yh.test(e.nodeValue) : !0 : t.filter(r => r instanceof RegExp).some(r => r.test(n)) }; function wh(e, t, n) { if (!e.length) return e; if (n && typeof n == "function") return n(e); const i = new window.DOMParser().parseFromString(e, "text/html"), s = [].concat(...i.body.querySelectorAll("*")); for (const o of s) { const a = o.nodeName.toLowerCase(); if (!Object.keys(t).includes(a)) { o.remove(); continue } const u = [].concat(...o.attributes), g = [].concat(t["*"] || [], t[a] || []); for (const _ of u) Ah(_, g) || o.removeAttribute(_.nodeName) } return i.body.innerHTML } const Th = "TemplateFactory", Sh = { allowList: Ta, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" }, Oh = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, Ch = { entry: "(string|element|function|null)", selector: "(string|element)" }; class xh extends Ne { constructor(t) { super(), this._config = this._getConfig(t) } static get Default() { return Sh } static get DefaultType() { return Oh } static get NAME() { return Th } getContent() { return Object.values(this._config.content).map(t => this._resolvePossibleFunction(t)).filter(Boolean) } hasContent() { return this.getContent().length > 0 } changeContent(t) { return this._checkContent(t), this._config.content = { ...this._config.content, ...t }, this } toHtml() { const t = document.createElement("div"); t.innerHTML = this._maybeSanitize(this._config.template); for (const [i, s] of Object.entries(this._config.content)) this._setContent(t, s, i); const n = t.children[0], r = this._resolvePossibleFunction(this._config.extraClass); return r && n.classList.add(...r.split(" ")), n } _typeCheckConfig(t) { super._typeCheckConfig(t), this._checkContent(t.content) } _checkContent(t) { for (const [n, r] of Object.entries(t)) super._typeCheckConfig({ selector: n, entry: r }, Ch) } _setContent(t, n, r) { const i = A.findOne(r, t); if (i) { if (n = this._resolvePossibleFunction(n), !n) { i.remove(); return } if (nt(n)) { this._putElementInTemplate(pt(n), i); return } if (this._config.html) { i.innerHTML = this._maybeSanitize(n); return } i.textContent = n } } _maybeSanitize(t) { return this._config.sanitize ? wh(t, this._config.allowList, this._config.sanitizeFn) : t } _resolvePossibleFunction(t) { return B(t, [this]) } _putElementInTemplate(t, n) { if (this._config.html) { n.innerHTML = "", n.append(t); return } n.textContent = t.textContent } } const Nh = "tooltip", Dh = new Set(["sanitize", "allowList", "sanitizeFn"]), jn = "fade", $h = "modal", ze = "show", Lh = ".tooltip-inner", os = `.${$h}`, as = "hide.bs.modal", de = "hover", Kn = "focus", Ih = "click", Mh = "manual", Ph = "hide", Rh = "hidden", Bh = "show", kh = "shown", Fh = "inserted", Vh = "click", Hh = "focusin", jh = "focusout", Kh = "mouseenter", Uh = "mouseleave", Wh = { AUTO: "auto", TOP: "top", RIGHT: K() ? "left" : "right", BOTTOM: "bottom", LEFT: K() ? "right" : "left" }, Yh = { allowList: Ta, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 6], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, zh = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" }; class oe extends X { constructor(t, n) { if (typeof Qo == "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(t, n), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default() { return Yh } static get DefaultType() { return zh } static get NAME() { return Nh } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle() { if (this._isEnabled) { if (this._activeTrigger.click = !this._activeTrigger.click, this._isShown()) { this._leave(); return } this._enter() } } dispose() { clearTimeout(this._timeout), v.off(this._element.closest(os), as, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose() } show() { if (this._element.style.display === "none") throw new Error("Please use show on visible elements"); if (!(this._isWithContent() && this._isEnabled)) return; const t = v.trigger(this._element, this.constructor.eventName(Bh)), r = (ta(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (t.defaultPrevented || !r) return; this._disposePopper(); const i = this._getTipElement(); this._element.setAttribute("aria-describedby", i.getAttribute("id")); const { container: s } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(i), v.trigger(this._element, this.constructor.eventName(Fh))), this._popper = this._createPopper(i), i.classList.add(ze), "ontouchstart" in document.documentElement) for (const a of [].concat(...document.body.children)) v.on(a, "mouseover", cn); const o = () => { v.trigger(this._element, this.constructor.eventName(kh)), this._isHovered === !1 && this._leave(), this._isHovered = !1 }; this._queueCallback(o, this.tip, this._isAnimated()) } hide() { if (!this._isShown() || v.trigger(this._element, this.constructor.eventName(Ph)).defaultPrevented) return; if (this._getTipElement().classList.remove(ze), "ontouchstart" in document.documentElement) for (const i of [].concat(...document.body.children)) v.off(i, "mouseover", cn); this._activeTrigger[Ih] = !1, this._activeTrigger[Kn] = !1, this._activeTrigger[de] = !1, this._isHovered = null; const r = () => { this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), v.trigger(this._element, this.constructor.eventName(Rh))) }; this._queueCallback(r, this.tip, this._isAnimated()) } update() { this._popper && this._popper.update() } _isWithContent() { return !!this._getTitle() } _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip } _createTipElement(t) { const n = this._getTemplateFactory(t).toHtml(); if (!n) return null; n.classList.remove(jn, ze), n.classList.add(`bs-${this.constructor.NAME}-auto`); const r = Lu(this.constructor.NAME).toString(); return n.setAttribute("id", r), this._isAnimated() && n.classList.add(jn), n } setContent(t) { this._newContent = t, this._isShown() && (this._disposePopper(), this.show()) } _getTemplateFactory(t) { return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new xh({ ...this._config, content: t, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory } _getContentForTemplate() { return { [Lh]: this._getTitle() } } _getTitle() { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title") } _initializeOnDelegatedTarget(t) { return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig()) } _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(jn) } _isShown() { return this.tip && this.tip.classList.contains(ze) } _createPopper(t) { const n = B(this._config.placement, [this, t, this._element]), r = Wh[n.toUpperCase()]; return ri(this._element, t, this._getPopperConfig(r)) } _getOffset() { const { offset: t } = this._config; return typeof t == "string" ? t.split(",").map(n => Number.parseInt(n, 10)) : typeof t == "function" ? n => t(n, this._element) : t } _resolvePossibleFunction(t) { return B(t, [this._element]) } _getPopperConfig(t) { const n = { placement: t, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: r => { this._getTipElement().setAttribute("data-popper-placement", r.state.placement) } }] }; return { ...n, ...B(this._config.popperConfig, [n]) } } _setListeners() { const t = this._config.trigger.split(" "); for (const n of t) if (n === "click") v.on(this._element, this.constructor.eventName(Vh), this._config.selector, r => { this._initializeOnDelegatedTarget(r).toggle() }); else if (n !== Mh) { const r = n === de ? this.constructor.eventName(Kh) : this.constructor.eventName(Hh), i = n === de ? this.constructor.eventName(Uh) : this.constructor.eventName(jh); v.on(this._element, r, this._config.selector, s => { const o = this._initializeOnDelegatedTarget(s); o._activeTrigger[s.type === "focusin" ? Kn : de] = !0, o._enter() }), v.on(this._element, i, this._config.selector, s => { const o = this._initializeOnDelegatedTarget(s); o._activeTrigger[s.type === "focusout" ? Kn : de] = o._element.contains(s.relatedTarget), o._leave() }) } this._hideModalHandler = () => { this._element && this.hide() }, v.on(this._element.closest(os), as, this._hideModalHandler) } _fixTitle() { const t = this._element.getAttribute("title"); t && (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title")) } _enter() { if (this._isShown() || this._isHovered) { this._isHovered = !0; return } this._isHovered = !0, this._setTimeout(() => { this._isHovered && this.show() }, this._config.delay.show) } _leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => { this._isHovered || this.hide() }, this._config.delay.hide)) } _setTimeout(t, n) { clearTimeout(this._timeout), this._timeout = setTimeout(t, n) } _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) } _getConfig(t) { const n = rt.getDataAttributes(this._element); for (const r of Object.keys(n)) Dh.has(r) && delete n[r]; return t = { ...n, ...typeof t == "object" && t ? t : {} }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t } _configAfterMerge(t) { return t.container = t.container === !1 ? document.body : pt(t.container), typeof t.delay == "number" && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), t } _getDelegateConfig() { const t = {}; for (const [n, r] of Object.entries(this._config)) this.constructor.Default[n] !== r && (t[n] = r); return t.selector = !1, t.trigger = "manual", t } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null) } static jQueryInterface(t) { return this.each(function () { const n = oe.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof n[t] == "undefined") throw new TypeError(`No method named "${t}"`); n[t]() } }) } } W(oe); const qh = "popover", Gh = ".popover-header", Xh = ".popover-body", Qh = { ...oe.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, Jh = { ...oe.DefaultType, content: "(null|string|element|function)" }; class ai extends oe { static get Default() { return Qh } static get DefaultType() { return Jh } static get NAME() { return qh } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { [Gh]: this._getTitle(), [Xh]: this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(t) { return this.each(function () { const n = ai.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof n[t] == "undefined") throw new TypeError(`No method named "${t}"`); n[t]() } }) } } W(ai); const Zh = "scrollspy", tp = "bs.scrollspy", ci = `.${tp}`, ep = ".data-api", np = `activate${ci}`, cs = `click${ci}`, rp = `load${ci}${ep}`, ip = "dropdown-item", Vt = "active", sp = '[data-bs-spy="scroll"]', Un = "[href]", op = ".nav, .list-group", ls = ".nav-link", ap = ".nav-item", cp = ".list-group-item", lp = `${ls}, ${ap} > ${ls}, ${cp}`, up = ".dropdown", fp = ".dropdown-toggle", dp = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1] }, hp = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" }; class wn extends X { constructor(t, n) { super(t, n), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return dp } static get DefaultType() { return hp } static get NAME() { return Zh } refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const t of this._observableSections.values()) this._observer.observe(t) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(t) { return t.target = pt(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, typeof t.threshold == "string" && (t.threshold = t.threshold.split(",").map(n => Number.parseFloat(n))), t } _maybeEnableSmoothScroll() { this._config.smoothScroll && (v.off(this._config.target, cs), v.on(this._config.target, cs, Un, t => { const n = this._observableSections.get(t.target.hash); if (n) { t.preventDefault(); const r = this._rootElement || window, i = n.offsetTop - this._element.offsetTop; if (r.scrollTo) { r.scrollTo({ top: i, behavior: "smooth" }); return } r.scrollTop = i } })) } _getNewObserver() { const t = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver(n => this._observerCallback(n), t) } _observerCallback(t) { const n = o => this._targetLinks.get(`#${o.target.id}`), r = o => { this._previousScrollData.visibleEntryTop = o.target.offsetTop, this._process(n(o)) }, i = (this._rootElement || document.documentElement).scrollTop, s = i >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = i; for (const o of t) { if (!o.isIntersecting) { this._activeTarget = null, this._clearActiveClass(n(o)); continue } const a = o.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (s && a) { if (r(o), !i) return; continue } !s && !a && r(o) } } _initializeTargetsAndObservables() { this._targetLinks = new Map, this._observableSections = new Map; const t = A.find(Un, this._config.target); for (const n of t) { if (!n.hash || _t(n)) continue; const r = A.findOne(decodeURI(n.hash), this._element); ie(r) && (this._targetLinks.set(decodeURI(n.hash), n), this._observableSections.set(n.hash, r)) } } _process(t) { this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(Vt), this._activateParents(t), v.trigger(this._element, np, { relatedTarget: t })) } _activateParents(t) { if (t.classList.contains(ip)) { A.findOne(fp, t.closest(up)).classList.add(Vt); return } for (const n of A.parents(t, op)) for (const r of A.prev(n, lp)) r.classList.add(Vt) } _clearActiveClass(t) { t.classList.remove(Vt); const n = A.find(`${Un}.${Vt}`, t); for (const r of n) r.classList.remove(Vt) } static jQueryInterface(t) { return this.each(function () { const n = wn.getOrCreateInstance(this, t); if (typeof t == "string") { if (n[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); n[t]() } }) } } v.on(window, rp, () => { for (const e of A.find(sp)) wn.getOrCreateInstance(e) }); W(wn); const pp = "tab", _p = "bs.tab", Bt = `.${_p}`, gp = `hide${Bt}`, mp = `hidden${Bt}`, vp = `show${Bt}`, Ep = `shown${Bt}`, bp = `click${Bt}`, yp = `keydown${Bt}`, Ap = `load${Bt}`, wp = "ArrowLeft", us = "ArrowRight", Tp = "ArrowUp", fs = "ArrowDown", Wn = "Home", ds = "End", xt = "active", hs = "fade", Yn = "show", Sp = "dropdown", Sa = ".dropdown-toggle", Op = ".dropdown-menu", zn = `:not(${Sa})`, Cp = '.list-group, .nav, [role="tablist"]', xp = ".nav-item, .list-group-item", Np = `.nav-link${zn}, .list-group-item${zn}, [role="tab"]${zn}`, Oa = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', qn = `${Np}, ${Oa}`, Dp = `.${xt}[data-bs-toggle="tab"], .${xt}[data-bs-toggle="pill"], .${xt}[data-bs-toggle="list"]`; class Zt extends X { constructor(t) { super(t), this._parent = this._element.closest(Cp), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), v.on(this._element, yp, n => this._keydown(n))) } static get NAME() { return pp } show() { const t = this._element; if (this._elemIsActive(t)) return; const n = this._getActiveElem(), r = n ? v.trigger(n, gp, { relatedTarget: t }) : null; v.trigger(t, vp, { relatedTarget: n }).defaultPrevented || r && r.defaultPrevented || (this._deactivate(n, t), this._activate(t, n)) } _activate(t, n) { if (!t) return; t.classList.add(xt), this._activate(A.getElementFromSelector(t)); const r = () => { if (t.getAttribute("role") !== "tab") { t.classList.add(Yn); return } t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), v.trigger(t, Ep, { relatedTarget: n }) }; this._queueCallback(r, t, t.classList.contains(hs)) } _deactivate(t, n) { if (!t) return; t.classList.remove(xt), t.blur(), this._deactivate(A.getElementFromSelector(t)); const r = () => { if (t.getAttribute("role") !== "tab") { t.classList.remove(Yn); return } t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), v.trigger(t, mp, { relatedTarget: n }) }; this._queueCallback(r, t, t.classList.contains(hs)) } _keydown(t) { if (![wp, us, Tp, fs, Wn, ds].includes(t.key)) return; t.stopPropagation(), t.preventDefault(); const n = this._getChildren().filter(i => !_t(i)); let r; if ([Wn, ds].includes(t.key)) r = n[t.key === Wn ? 0 : n.length - 1]; else { const i = [us, fs].includes(t.key); r = ii(n, t.target, i, !0) } r && (r.focus({ preventScroll: !0 }), Zt.getOrCreateInstance(r).show()) } _getChildren() { return A.find(qn, this._parent) } _getActiveElem() { return this._getChildren().find(t => this._elemIsActive(t)) || null } _setInitialAttributes(t, n) { this._setAttributeIfNotExists(t, "role", "tablist"); for (const r of n) this._setInitialAttributesOnChild(r) } _setInitialAttributesOnChild(t) { t = this._getInnerElement(t); const n = this._elemIsActive(t), r = this._getOuterElement(t); t.setAttribute("aria-selected", n), r !== t && this._setAttributeIfNotExists(r, "role", "presentation"), n || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t) } _setInitialAttributesOnTargetPanel(t) { const n = A.getElementFromSelector(t); n && (this._setAttributeIfNotExists(n, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(n, "aria-labelledby", `${t.id}`)) } _toggleDropDown(t, n) { const r = this._getOuterElement(t); if (!r.classList.contains(Sp)) return; const i = (s, o) => { const a = A.findOne(s, r); a && a.classList.toggle(o, n) }; i(Sa, xt), i(Op, Yn), r.setAttribute("aria-expanded", n) } _setAttributeIfNotExists(t, n, r) { t.hasAttribute(n) || t.setAttribute(n, r) } _elemIsActive(t) { return t.classList.contains(xt) } _getInnerElement(t) { return t.matches(qn) ? t : A.findOne(qn, t) } _getOuterElement(t) { return t.closest(xp) || t } static jQueryInterface(t) { return this.each(function () { const n = Zt.getOrCreateInstance(this); if (typeof t == "string") { if (n[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); n[t]() } }) } } v.on(document, bp, Oa, function (e) { ["A", "AREA"].includes(this.tagName) && e.preventDefault(), !_t(this) && Zt.getOrCreateInstance(this).show() }); v.on(window, Ap, () => { for (const e of A.find(Dp)) Zt.getOrCreateInstance(e) }); W(Zt); const $p = "toast", Lp = "bs.toast", Et = `.${Lp}`, Ip = `mouseover${Et}`, Mp = `mouseout${Et}`, Pp = `focusin${Et}`, Rp = `focusout${Et}`, Bp = `hide${Et}`, kp = `hidden${Et}`, Fp = `show${Et}`, Vp = `shown${Et}`, Hp = "fade", ps = "hide", qe = "show", Ge = "showing", jp = { animation: "boolean", autohide: "boolean", delay: "number" }, Kp = { animation: !0, autohide: !0, delay: 5e3 }; class Tn extends X { constructor(t, n) { super(t, n), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return Kp } static get DefaultType() { return jp } static get NAME() { return $p } show() { if (v.trigger(this._element, Fp).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add(Hp); const n = () => { this._element.classList.remove(Ge), v.trigger(this._element, Vp), this._maybeScheduleHide() }; this._element.classList.remove(ps), xe(this._element), this._element.classList.add(qe, Ge), this._queueCallback(n, this._element, this._config.animation) } hide() { if (!this.isShown() || v.trigger(this._element, Bp).defaultPrevented) return; const n = () => { this._element.classList.add(ps), this._element.classList.remove(Ge, qe), v.trigger(this._element, kp) }; this._element.classList.add(Ge), this._queueCallback(n, this._element, this._config.animation) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(qe), super.dispose() } isShown() { return this._element.classList.contains(qe) } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay))) } _onInteraction(t, n) { switch (t.type) { case "mouseover": case "mouseout": { this._hasMouseInteraction = n; break } case "focusin": case "focusout": { this._hasKeyboardInteraction = n; break } }if (n) { this._clearTimeout(); return } const r = t.relatedTarget; this._element === r || this._element.contains(r) || this._maybeScheduleHide() } _setListeners() { v.on(this._element, Ip, t => this._onInteraction(t, !0)), v.on(this._element, Mp, t => this._onInteraction(t, !1)), v.on(this._element, Pp, t => this._onInteraction(t, !0)), v.on(this._element, Rp, t => this._onInteraction(t, !1)) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each(function () { const n = Tn.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof n[t] == "undefined") throw new TypeError(`No method named "${t}"`); n[t](this) } }) } } yn(Tn); W(Tn); var Ca = { exports: {} }; (function (e, t) { (function (n) { e.exports = n() })(function (n) { var r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"]; function i(p, h) { var l = p[0], c = p[1], d = p[2], f = p[3]; l += (c & d | ~c & f) + h[0] - 680876936 | 0, l = (l << 7 | l >>> 25) + c | 0, f += (l & c | ~l & d) + h[1] - 389564586 | 0, f = (f << 12 | f >>> 20) + l | 0, d += (f & l | ~f & c) + h[2] + 606105819 | 0, d = (d << 17 | d >>> 15) + f | 0, c += (d & f | ~d & l) + h[3] - 1044525330 | 0, c = (c << 22 | c >>> 10) + d | 0, l += (c & d | ~c & f) + h[4] - 176418897 | 0, l = (l << 7 | l >>> 25) + c | 0, f += (l & c | ~l & d) + h[5] + 1200080426 | 0, f = (f << 12 | f >>> 20) + l | 0, d += (f & l | ~f & c) + h[6] - 1473231341 | 0, d = (d << 17 | d >>> 15) + f | 0, c += (d & f | ~d & l) + h[7] - 45705983 | 0, c = (c << 22 | c >>> 10) + d | 0, l += (c & d | ~c & f) + h[8] + 1770035416 | 0, l = (l << 7 | l >>> 25) + c | 0, f += (l & c | ~l & d) + h[9] - 1958414417 | 0, f = (f << 12 | f >>> 20) + l | 0, d += (f & l | ~f & c) + h[10] - 42063 | 0, d = (d << 17 | d >>> 15) + f | 0, c += (d & f | ~d & l) + h[11] - 1990404162 | 0, c = (c << 22 | c >>> 10) + d | 0, l += (c & d | ~c & f) + h[12] + 1804603682 | 0, l = (l << 7 | l >>> 25) + c | 0, f += (l & c | ~l & d) + h[13] - 40341101 | 0, f = (f << 12 | f >>> 20) + l | 0, d += (f & l | ~f & c) + h[14] - 1502002290 | 0, d = (d << 17 | d >>> 15) + f | 0, c += (d & f | ~d & l) + h[15] + 1236535329 | 0, c = (c << 22 | c >>> 10) + d | 0, l += (c & f | d & ~f) + h[1] - 165796510 | 0, l = (l << 5 | l >>> 27) + c | 0, f += (l & d | c & ~d) + h[6] - 1069501632 | 0, f = (f << 9 | f >>> 23) + l | 0, d += (f & c | l & ~c) + h[11] + 643717713 | 0, d = (d << 14 | d >>> 18) + f | 0, c += (d & l | f & ~l) + h[0] - 373897302 | 0, c = (c << 20 | c >>> 12) + d | 0, l += (c & f | d & ~f) + h[5] - 701558691 | 0, l = (l << 5 | l >>> 27) + c | 0, f += (l & d | c & ~d) + h[10] + 38016083 | 0, f = (f << 9 | f >>> 23) + l | 0, d += (f & c | l & ~c) + h[15] - 660478335 | 0, d = (d << 14 | d >>> 18) + f | 0, c += (d & l | f & ~l) + h[4] - 405537848 | 0, c = (c << 20 | c >>> 12) + d | 0, l += (c & f | d & ~f) + h[9] + 568446438 | 0, l = (l << 5 | l >>> 27) + c | 0, f += (l & d | c & ~d) + h[14] - 1019803690 | 0, f = (f << 9 | f >>> 23) + l | 0, d += (f & c | l & ~c) + h[3] - 187363961 | 0, d = (d << 14 | d >>> 18) + f | 0, c += (d & l | f & ~l) + h[8] + 1163531501 | 0, c = (c << 20 | c >>> 12) + d | 0, l += (c & f | d & ~f) + h[13] - 1444681467 | 0, l = (l << 5 | l >>> 27) + c | 0, f += (l & d | c & ~d) + h[2] - 51403784 | 0, f = (f << 9 | f >>> 23) + l | 0, d += (f & c | l & ~c) + h[7] + 1735328473 | 0, d = (d << 14 | d >>> 18) + f | 0, c += (d & l | f & ~l) + h[12] - 1926607734 | 0, c = (c << 20 | c >>> 12) + d | 0, l += (c ^ d ^ f) + h[5] - 378558 | 0, l = (l << 4 | l >>> 28) + c | 0, f += (l ^ c ^ d) + h[8] - 2022574463 | 0, f = (f << 11 | f >>> 21) + l | 0, d += (f ^ l ^ c) + h[11] + 1839030562 | 0, d = (d << 16 | d >>> 16) + f | 0, c += (d ^ f ^ l) + h[14] - 35309556 | 0, c = (c << 23 | c >>> 9) + d | 0, l += (c ^ d ^ f) + h[1] - 1530992060 | 0, l = (l << 4 | l >>> 28) + c | 0, f += (l ^ c ^ d) + h[4] + 1272893353 | 0, f = (f << 11 | f >>> 21) + l | 0, d += (f ^ l ^ c) + h[7] - 155497632 | 0, d = (d << 16 | d >>> 16) + f | 0, c += (d ^ f ^ l) + h[10] - 1094730640 | 0, c = (c << 23 | c >>> 9) + d | 0, l += (c ^ d ^ f) + h[13] + 681279174 | 0, l = (l << 4 | l >>> 28) + c | 0, f += (l ^ c ^ d) + h[0] - 358537222 | 0, f = (f << 11 | f >>> 21) + l | 0, d += (f ^ l ^ c) + h[3] - 722521979 | 0, d = (d << 16 | d >>> 16) + f | 0, c += (d ^ f ^ l) + h[6] + 76029189 | 0, c = (c << 23 | c >>> 9) + d | 0, l += (c ^ d ^ f) + h[9] - 640364487 | 0, l = (l << 4 | l >>> 28) + c | 0, f += (l ^ c ^ d) + h[12] - 421815835 | 0, f = (f << 11 | f >>> 21) + l | 0, d += (f ^ l ^ c) + h[15] + 530742520 | 0, d = (d << 16 | d >>> 16) + f | 0, c += (d ^ f ^ l) + h[2] - 995338651 | 0, c = (c << 23 | c >>> 9) + d | 0, l += (d ^ (c | ~f)) + h[0] - 198630844 | 0, l = (l << 6 | l >>> 26) + c | 0, f += (c ^ (l | ~d)) + h[7] + 1126891415 | 0, f = (f << 10 | f >>> 22) + l | 0, d += (l ^ (f | ~c)) + h[14] - 1416354905 | 0, d = (d << 15 | d >>> 17) + f | 0, c += (f ^ (d | ~l)) + h[5] - 57434055 | 0, c = (c << 21 | c >>> 11) + d | 0, l += (d ^ (c | ~f)) + h[12] + 1700485571 | 0, l = (l << 6 | l >>> 26) + c | 0, f += (c ^ (l | ~d)) + h[3] - 1894986606 | 0, f = (f << 10 | f >>> 22) + l | 0, d += (l ^ (f | ~c)) + h[10] - 1051523 | 0, d = (d << 15 | d >>> 17) + f | 0, c += (f ^ (d | ~l)) + h[1] - 2054922799 | 0, c = (c << 21 | c >>> 11) + d | 0, l += (d ^ (c | ~f)) + h[8] + 1873313359 | 0, l = (l << 6 | l >>> 26) + c | 0, f += (c ^ (l | ~d)) + h[15] - 30611744 | 0, f = (f << 10 | f >>> 22) + l | 0, d += (l ^ (f | ~c)) + h[6] - 1560198380 | 0, d = (d << 15 | d >>> 17) + f | 0, c += (f ^ (d | ~l)) + h[13] + 1309151649 | 0, c = (c << 21 | c >>> 11) + d | 0, l += (d ^ (c | ~f)) + h[4] - 145523070 | 0, l = (l << 6 | l >>> 26) + c | 0, f += (c ^ (l | ~d)) + h[11] - 1120210379 | 0, f = (f << 10 | f >>> 22) + l | 0, d += (l ^ (f | ~c)) + h[2] + 718787259 | 0, d = (d << 15 | d >>> 17) + f | 0, c += (f ^ (d | ~l)) + h[9] - 343485551 | 0, c = (c << 21 | c >>> 11) + d | 0, p[0] = l + p[0] | 0, p[1] = c + p[1] | 0, p[2] = d + p[2] | 0, p[3] = f + p[3] | 0 } function s(p) { var h = [], l; for (l = 0; l < 64; l += 4)h[l >> 2] = p.charCodeAt(l) + (p.charCodeAt(l + 1) << 8) + (p.charCodeAt(l + 2) << 16) + (p.charCodeAt(l + 3) << 24); return h } function o(p) { var h = [], l; for (l = 0; l < 64; l += 4)h[l >> 2] = p[l] + (p[l + 1] << 8) + (p[l + 2] << 16) + (p[l + 3] << 24); return h } function a(p) { var h = p.length, l = [1732584193, -271733879, -1732584194, 271733878], c, d, f, T, O, C; for (c = 64; c <= h; c += 64)i(l, s(p.substring(c - 64, c))); for (p = p.substring(c - 64), d = p.length, f = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], c = 0; c < d; c += 1)f[c >> 2] |= p.charCodeAt(c) << (c % 4 << 3); if (f[c >> 2] |= 128 << (c % 4 << 3), c > 55) for (i(l, f), c = 0; c < 16; c += 1)f[c] = 0; return T = h * 8, T = T.toString(16).match(/(.*?)(.{0,8})$/), O = parseInt(T[2], 16), C = parseInt(T[1], 16) || 0, f[14] = O, f[15] = C, i(l, f), l } function u(p) { var h = p.length, l = [1732584193, -271733879, -1732584194, 271733878], c, d, f, T, O, C; for (c = 64; c <= h; c += 64)i(l, o(p.subarray(c - 64, c))); for (p = c - 64 < h ? p.subarray(c - 64) : new Uint8Array(0), d = p.length, f = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], c = 0; c < d; c += 1)f[c >> 2] |= p[c] << (c % 4 << 3); if (f[c >> 2] |= 128 << (c % 4 << 3), c > 55) for (i(l, f), c = 0; c < 16; c += 1)f[c] = 0; return T = h * 8, T = T.toString(16).match(/(.*?)(.{0,8})$/), O = parseInt(T[2], 16), C = parseInt(T[1], 16) || 0, f[14] = O, f[15] = C, i(l, f), l } function g(p) { var h = "", l; for (l = 0; l < 4; l += 1)h += r[p >> l * 8 + 4 & 15] + r[p >> l * 8 & 15]; return h } function _(p) { var h; for (h = 0; h < p.length; h += 1)p[h] = g(p[h]); return p.join("") } _(a("hello")), typeof ArrayBuffer != "undefined" && !ArrayBuffer.prototype.slice && function () { function p(h, l) { return h = h | 0 || 0, h < 0 ? Math.max(h + l, 0) : Math.min(h, l) } ArrayBuffer.prototype.slice = function (h, l) { var c = this.byteLength, d = p(h, c), f = c, T, O, C, x; return l !== n && (f = p(l, c)), d > f ? new ArrayBuffer(0) : (T = f - d, O = new ArrayBuffer(T), C = new Uint8Array(O), x = new Uint8Array(this, d, T), C.set(x), O) } }(); function E(p) { return /[\u0080-\uFFFF]/.test(p) && (p = unescape(encodeURIComponent(p))), p } function b(p, h) { var l = p.length, c = new ArrayBuffer(l), d = new Uint8Array(c), f; for (f = 0; f < l; f += 1)d[f] = p.charCodeAt(f); return h ? d : c } function y(p) { return String.fromCharCode.apply(null, new Uint8Array(p)) } function S(p, h, l) { var c = new Uint8Array(p.byteLength + h.byteLength); return c.set(new Uint8Array(p)), c.set(new Uint8Array(h), p.byteLength), l ? c : c.buffer } function w(p) { var h = [], l = p.length, c; for (c = 0; c < l - 1; c += 2)h.push(parseInt(p.substr(c, 2), 16)); return String.fromCharCode.apply(String, h) } function m() { this.reset() } return m.prototype.append = function (p) { return this.appendBinary(E(p)), this }, m.prototype.appendBinary = function (p) { this._buff += p, this._length += p.length; var h = this._buff.length, l; for (l = 64; l <= h; l += 64)i(this._hash, s(this._buff.substring(l - 64, l))); return this._buff = this._buff.substring(l - 64), this }, m.prototype.end = function (p) { var h = this._buff, l = h.length, c, d = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], f; for (c = 0; c < l; c += 1)d[c >> 2] |= h.charCodeAt(c) << (c % 4 << 3); return this._finish(d, l), f = _(this._hash), p && (f = w(f)), this.reset(), f }, m.prototype.reset = function () { return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this }, m.prototype.getState = function () { return { buff: this._buff, length: this._length, hash: this._hash.slice() } }, m.prototype.setState = function (p) { return this._buff = p.buff, this._length = p.length, this._hash = p.hash, this }, m.prototype.destroy = function () { delete this._hash, delete this._buff, delete this._length }, m.prototype._finish = function (p, h) { var l = h, c, d, f; if (p[l >> 2] |= 128 << (l % 4 << 3), l > 55) for (i(this._hash, p), l = 0; l < 16; l += 1)p[l] = 0; c = this._length * 8, c = c.toString(16).match(/(.*?)(.{0,8})$/), d = parseInt(c[2], 16), f = parseInt(c[1], 16) || 0, p[14] = d, p[15] = f, i(this._hash, p) }, m.hash = function (p, h) { return m.hashBinary(E(p), h) }, m.hashBinary = function (p, h) { var l = a(p), c = _(l); return h ? w(c) : c }, m.ArrayBuffer = function () { this.reset() }, m.ArrayBuffer.prototype.append = function (p) { var h = S(this._buff.buffer, p, !0), l = h.length, c; for (this._length += p.byteLength, c = 64; c <= l; c += 64)i(this._hash, o(h.subarray(c - 64, c))); return this._buff = c - 64 < l ? new Uint8Array(h.buffer.slice(c - 64)) : new Uint8Array(0), this }, m.ArrayBuffer.prototype.end = function (p) { var h = this._buff, l = h.length, c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], d, f; for (d = 0; d < l; d += 1)c[d >> 2] |= h[d] << (d % 4 << 3); return this._finish(c, l), f = _(this._hash), p && (f = w(f)), this.reset(), f }, m.ArrayBuffer.prototype.reset = function () { return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this }, m.ArrayBuffer.prototype.getState = function () { var p = m.prototype.getState.call(this); return p.buff = y(p.buff), p }, m.ArrayBuffer.prototype.setState = function (p) { return p.buff = b(p.buff, !0), m.prototype.setState.call(this, p) }, m.ArrayBuffer.prototype.destroy = m.prototype.destroy, m.ArrayBuffer.prototype._finish = m.prototype._finish, m.ArrayBuffer.hash = function (p, h) { var l = u(new Uint8Array(p)), c = _(l); return h ? w(c) : c }, m }) })(Ca); var Up = Ca.exports; function yr(e, t = 0, n = e.byteLength - t, r = !1) { const i = new Uint8Array(e.buffer, t, n); return r ? i.reduceRight((s, o) => (s << 8n) + BigInt(o), 0n) : i.reduce((s, o) => (s << 8n) + BigInt(o), 0n) } function Ar(e, t, n, r = !1) { if (r) for (; n > 0n;)e.setBigUint64(t, n, !0), t += 8, n >>= 64n; else { const i = []; for (; n > 0n;)i.push(BigInt.asUintN(64, n)), n >>= 64n; for (let s = i.length - 1; s >= 0; s -= 1)e.setBigUint64(t, i[s], !1), t += 8 } } function Wp(e, t = !1) { const n = new ArrayBuffer(Math.ceil(e.toString(2).length / 8)), r = new DataView(n); return Ar(r, 0, e, t), n } function Yp(e, t, n) { if (n === 1n) return 0n; let r = 1n; for (e = e % n; t > 0n;)BigInt.asUintN(1, t) === 1n && (r = r * e % n), e = e * e % n, t >>= 1n; return r } function zp(e, t) { if (e = (e % t + t) % t, !e || t < 2) return NaN; const n = []; let r = t; for (; r;) [e, r] = [r, e % r], n.push({ a: e, b: r }); if (e !== 1) return NaN; let i = 1, s = 0; for (let o = n.length - 2; o >= 0; o -= 1) [i, s] = [s, i - s * Math.floor(n[o].a / n[o].b)]; return (s % t + t) % t } const qp = 38, Gp = 303, Xp = 2048 / 8, Qp = 2048 / 8, Jp = 2048 / 8, Zp = Jp / 4, t_ = 65537; function xa(e) { typeof e == "string" && (e = e_(e)); const t = new DataView(e.buffer); return { n: yr(t, qp, Xp), d: yr(t, Gp, Qp) } } function e_(e) { return Uint8Array.from(window.atob(e), t => t.charCodeAt(0)) } function li(e) { return window.btoa(String.fromCharCode(...new Uint8Array(e))) } async function n_() { const e = await crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-1" } }, !0, ["sign", "verify"]); return li(await crypto.subtle.exportKey("pkcs8", e.privateKey)) } function r_({ privateKey: e, username: t, hostname: n }) { const r = new Uint8Array(524), i = new DataView(r.buffer), { n: s } = xa(e); return i.setUint32(0, Zp, !0), i.setUint32(4, zp(-Number(BigInt.asUintN(32, s)), 2 ** 32), !0), Ar(i, 8, s, !0), Ar(i, 264, 2n ** 4096n % s, !0), i.setUint32(520, t_, !0), `${li(r)} ${t != null ? t : "unknown"}@${n != null ? n : "unknown"}` } function i_(e, t) { const n = Uint8Array.from([0, 1, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); n.set(new Uint8Array(t), 236); const { d: r, n: i } = xa(e); return Wp(Yp(yr(new DataView(n.buffer)), r, i)) } function s_(e) { return typeof e != "string" && (e = li(e)), Up.hashBinary(window.atob(e.split(" ")[0])).match(/.{1,2}/g).join(":").toUpperCase() } async function o_(e, t, n) { if (t <= 0) return await e; let r; return await Promise.race([e, new Promise((i, s) => { r = setTimeout(s, t, n != null ? n : new Error("request time out")) })]).finally(() => { clearTimeout(r) }) } var Na = (e => (e.SHELL_V2 = "shell_v2", e))(Na || {}); class Ee { constructor() { et(this, "device"); et(this, "endpoints"); et(this, "banner"); if (!navigator.usb) throw new Error("browser not support WebUSB") } static loadEndpoints(t) { const n = r => t.alternate.endpoints.find(i => i.direction === r && i.type === "bulk").endpointNumber; return { in: n("in"), out: n("out") } } static checksum(t) { return !t || t.byteLength === 0 ? 0 : new Uint8Array(t).reduce((r, i) => r + i) & 4294967295 } async requestDevice() { if (!this.device) try { this.device = await navigator.usb.requestDevice({ filters: [{ classCode: 255, subclassCode: 66, protocolCode: 1 }] }) } catch { } return !!this.device } async reloadDevice() { return this.banner = void 0, this.device = (await navigator.usb.getDevices()).find(t => { var n, r; return (r = (n = t.configuration) == null ? void 0 : n.interfaces) == null ? void 0 : r.some(({ alternate: { interfaceClass: i, interfaceSubclass: s, interfaceProtocol: o } }) => i == 255 && s == 66 && o == 1) }), !!this.device } async forgetDevice() { var t; await ((t = this.device) == null ? void 0 : t.forget()), this.device = void 0, this.banner = void 0 } supportForget() { if (this.device) return typeof this.device.forget == "function" } async open() { var o; if (!this.device) return; await this.device.open(); const { confInterface: t, confInterface: { claimed: n, interfaceNumber: r }, configurationValue: i, alternateSetting: s } = this.filterConfiguration(); if (((o = this.device.configuration) == null ? void 0 : o.configurationValue) !== i && await this.device.selectConfiguration(i), !n) try { await this.device.claimInterface(r) } catch { throw new Error("\u672A\u77E5\u8F6F\u4EF6\u6B63\u5728\u5360\u7528 Adb\uFF0C\u8BF7\u91CD\u65B0\u63D2\u62D4\u6570\u636E\u7EBF\u7EE7\u7EED") } t.alternate.alternateSetting != s && await this.device.selectAlternateInterface(r, s), this.endpoints = Ee.loadEndpoints(t) } async pair({ privateKey: t, publicKey: n, userGestureCallback: r }) { await this.send({ command: 1314410051, arg0: 16777216, arg1: 262144, data: "host::stopapp" }); const { data: i } = await this.receiveExpect({ command: 1213486401, arg0: 1 }); await this.send({ command: 1213486401, arg0: 2, data: i_(t, i.buffer) }); let s = await this.receive(); if (s.command !== 1314410051) if (s.command === 1213486401) { await this.send({ command: 1213486401, arg0: 3, data: n }); const o = s_(n); r == null || r(o), s = await this.receiveExpect({ command: 1314410051 }) } else throw new Error("unknown command"); this.banner = this.parseBanner(new TextDecoder().decode(s.data)) } parseBanner(t) { return t.slice(8).split(";").reduce((n, r) => { if (!r.includes("=")) return n; const [i, s] = r.split("="); return i === "features" ? n.features = s.split(",") : Reflect.set(n, i, s), n }, {}) } isSupportedFeature(t) { var n, r; if (!this.banner) throw new Error("device is null, reload first!"); return (r = (n = this.banner.features) == null ? void 0 : n.includes(t)) != null ? r : !1 } async exec(t) { await this.send({ command: 1313165391, arg0: 1, arg1: 0, data: `shell:${t}` }), await this.receiveExpect({ command: 1497451343 }); const n = [], r = new TextDecoder; let i; for (; i = await this.receive();) { if (i.command == 1163154007) { if (await this.send({ command: 1497451343, arg0: i.arg1, arg1: i.arg0 }), !i.data) continue } else if (i.command == 1163086915) { await this.send({ command: 1163086915, arg0: i.arg1, arg1: i.arg0 }); break } else throw new Error("unknown command"); const s = r.decode(i.data.buffer); n.push(s) } return n.length ? n.join() : null } async execV2(t) { if (!this.isSupportedFeature("shell_v2")) throw new Error("not support shell_v2"); await this.send({ command: 1313165391, arg0: 1, arg1: 0, data: `shell,v2,raw:${t}` }), await this.receiveExpect({ command: 1497451343 }); const [n, r] = [[], []], i = new TextDecoder; let s, o; for (; o = await this.receive();) { if (o.command == 1163154007) { if (await this.send({ command: 1497451343, arg0: o.arg1, arg1: o.arg0 }), !o.data) continue } else if (o.command === 1163086915) { await this.send({ command: 1163086915, arg0: o.arg1, arg1: o.arg0 }), await this.receiveExpect({ command: 1163086915 }); try { await o_(this.receiveExpect({ command: 1163086915 }), 300) } catch { } break } else throw new Error("unknown command"); const a = o.data.getInt8(0), u = o.data.getUint32(1, !0), g = new Uint8Array(o.data.buffer).slice(5, 5 + u); if ([1, 2].includes(a)) { const _ = i.decode(g); a == 1 ? n.push(_) : r.push(_) } else a === 3 && (s = g[0]) } return { stdout: n.length ? n.join() : null, stderr: r.length ? r.join() : null, exitCode: s != null ? s : -1 } } async close() { var t, n, r; (t = this.device) != null && t.opened && (await this.device.releaseInterface((r = (n = this.device.configuration) == null ? void 0 : n.interfaces[0].interfaceNumber) != null ? r : 0), await this.device.close()) } filterConfiguration() { if (!this.device) throw new Error("device is null, reload first!"); for (const t of this.device.configurations) for (const n of t.interfaces) for (const r of n.alternates) if (r.interfaceClass === 255 && r.interfaceSubclass === 66 && r.interfaceProtocol === 1) return { confInterface: n, configurationValue: t.configurationValue, alternateSetting: r.alternateSetting }; throw new Error("can not find interface") } async read(t) { if (!this.device || !this.endpoints) throw new Error("device is null, reload first!"); const { data: n, status: r } = await this.device.transferIn(this.endpoints.in, t); if (r !== "ok") throw new Error("read status not ok"); return n } async write(t) { if (!this.device || !this.endpoints) throw new Error("device is null, reload first!"); const { bytesWritten: n, status: r } = await this.device.transferOut(this.endpoints.out, t); if (n !== t.byteLength) throw new Error("written byte length not equal"); if (r !== "ok") throw new Error("write status not ok") } async receive() { const t = await this.read(24); if (!t) throw new Error("response is null"); const n = t.getUint32(0, !0), r = t.getUint32(4, !0), i = t.getUint32(8, !0), s = t.getUint32(12, !0), o = t.getUint32(16, !0), a = s ? await this.read(s) : void 0; return o != Ee.checksum(a == null ? void 0 : a.buffer), { command: n, arg0: r, arg1: i, data: a } } async send({ command: t, arg0: n, arg1: r, data: i }) { var a; const s = new ArrayBuffer(24); typeof i == "string" && (i = new TextEncoder().encode(i + "\0").buffer); const o = new DataView(s); o.setUint32(0, t, !0), o.setUint32(4, n != null ? n : 0, !0), o.setUint32(8, r != null ? r : 0, !0), o.setUint32(12, (a = i == null ? void 0 : i.byteLength) != null ? a : 0, !0), o.setUint32(16, Ee.checksum(i), !0), o.setUint32(20, t ^ 4294967295, !0), await this.write(s), i && await this.write(i) } async receiveExpect(t) { const n = await this.receive(); return Object.entries(t).some(([r, i]) => { if (Reflect.get(n, r) != i) throw new Error(`unexpected ${r} value`) }), n } } function Gn() { return "__TAURI__" in window } async function a_() { await window.__TAURI__.invoke("show_window") } function c_(e, t, n) { return Array.from(document.querySelectorAll(t)).map(r => e.getOrCreateInstance(r, n)) } async function l_() { let { privateKey: e, publicKey: t } = localStorage; return (!e || !t) && (e = await n_(), t = r_({ privateKey: e, username: Math.random().toString(16).substring(3), hostname: "adb.http.gs" }), Object.assign(localStorage, { privateKey: e, publicKey: t })), { privateKey: e, publicKey: t } } const u_ = `package="#PACKAGE_NAME#"
shell="#SHELL#"

if ! pm path "$package" >/dev/null; then
  echo -n "not_installed" >&2
  exit 1
fi

if [ ! -f "$shell" ]; then
  am force-stop "$package" >/dev/null 2>&1
  monkey -p "$package" -c android.intent.category.LAUNCHER 1 >/dev/null 2>&1

  sleep 3
  if [ ! -f "$shell" ]; then
    echo -n "no_starter" >&2
    exit 2
  fi
fi

result=$(sh "$shell" 2>&1)
if [ $? ]; then
  exit
fi

echo -n -e "$result" >&2
exit 3
`; class nn { constructor(t, n, r) { et(this, "name"); et(this, "_show"); et(this, "_run"); this.name = t, this._show = n, this._run = r } get show() { return this._show } get run() { return this._run } } class Xe extends nn { constructor(n, r, i) { super(n); et(this, "packageName"); et(this, "shell"); this.packageName = r, this.shell = i } get show() { return `adb shell sh ${this.shell}` } get run() { return u_.replace("#PACKAGE_NAME#", this.packageName).replace("#SHELL#", this.shell) } } const _s = [new Xe("\u5C0F\u9ED1\u5C4B\u9EA6\u514B\u65AF\u97E6\u5996\u6A21\u5F0F", "web1n.stopapp", "/sdcard/Android/data/web1n.stopapp/files/demon.sh"), new Xe("\u51B0\u7BB1\u666E\u901A ADB \u6A21\u5F0F", "com.catchingnow.icebox", "/sdcard/Android/data/com.catchingnow.icebox/files/start.sh"), new Xe("\u9ED1\u9608", "me.piebridge.brevent", "/data/data/me.piebridge.brevent/brevent.sh"), new Xe("Shizuku", "moe.shizuku.privileged.api", "/sdcard/Android/data/moe.shizuku.privileged.api/start.sh"), new nn("\u5C0F\u9ED1\u5C4B\u8BBE\u5907\u7BA1\u7406\u5458\u6A21\u5F0F", "adb shell dpm set-device-owner web1n.stopapp/.receiver.AdminReceiver", "dpm set-device-owner web1n.stopapp/.receiver.AdminReceiver"), new nn("\u51B0\u7BB1\u8BBE\u5907\u7BA1\u7406\u5458\u6A21\u5F0F", "adb shell dpm set-device-owner com.catchingnow.icebox/.receiver.DPMReceiver", "dpm set-device-owner com.catchingnow.icebox/.receiver.DPMReceiver"), new nn("\u5176\u4ED6\u6307\u4EE4")], f_ = () => ({ adb: null, result: null, message: null, processing: !1, key: void 0, shell: "", checked: 0, get shellShow() { var e; return (e = _s[this.checked]) == null ? void 0 : e.show }, get shells() { return _s }, get productName() { var e, t, n; return (n = (t = (e = this.adb) == null ? void 0 : e.device) == null ? void 0 : t.productName) != null ? n : "\u65E0\uFF0C\u70B9\u51FB\u6FC0\u6D3B\u6309\u94AE\u540E\u9009\u62E9\u8BBE\u5907" }, get supportForget() { var e; return (e = this.adb) == null ? void 0 : e.supportForget() }, get buildTime() { return new Date(1704003683070).toString() }, async init() { this.shell = this.shells[0].run, this.$watch("checked", e => { var t; this.shell = (t = this.shells[e].run) != null ? t : "" }), await this.initAdb(), Gn() && Ur.nextTick(async () => await a_()) }, async initAdb() { if (!this.isSupported()) return; this.adb = new Ee; const e = async () => { this.processing = !1, this.result = null, this.message = null, await this.adb.reloadDevice() && await this.active() }; navigator.usb.onconnect = e, navigator.usb.ondisconnect = e, this.key = await l_(), await this.adb.reloadDevice() }, async active() { if (!(!this.adb || !this.key)) { if (!this.shell.trim().length) { const e = this.$refs.shell; e.setCustomValidity("\u8BF7\u8F93\u5165\u6307\u4EE4"), e.reportValidity(); return } await this.adb.requestDevice() && (this.processing = !0, this.result = null, this.message = null, this.adb.open().then(() => this.adb.pair({ privateKey: this.key.privateKey, publicKey: this.key.publicKey, userGestureCallback: async e => { const t = `\u8BF7\u5728\u624B\u673A\u4E0A\u5141\u8BB8 USB \u8C03\u8BD5\uFF1A${e}`; Gn() ? alert(t) : this.message = t } })).then(() => (this.message = null, this.adb.isSupportedFeature(Na.SHELL_V2) ? this.adb.execV2(this.shell) : this.adb.exec(this.shell).then(e => ({ exitCode: -1, stdout: null, stderr: e })))).then(e => { this.showResult(e) }).finally(() => (this.processing = !1, this.adb.close())).catch(e => { this.message = e.message })) } }, async stop() { var e; (e = this.adb) == null || e.close().catch(t => { }).finally(() => { this.processing = !1, this.message = null }) }, async forget() { var e; await ((e = this.adb) == null ? void 0 : e.forgetDevice()), location.reload() }, showResult(e) { var s; const { stdout: t, stderr: n, exitCode: r } = e; let i; !n && !t ? r === 0 ? i = "\u6267\u884C\u6210\u529F" : i = `\u6267\u884C\u5931\u8D25\uFF0C\u8FD4\u56DE\u503C\uFF1A${r}` : n && (i = { not_installed: "\u672A\u5B89\u88C5\u6B64\u5E94\u7528", no_starter: "\u627E\u4E0D\u5230\u8FD0\u884C\u811A\u672C\uFF0C\u8BF7\u786E\u8BA4\u5DF2\u5728\u5BF9\u5E94\u5E94\u7528\u5185\u8BBE\u5B9A\u76F8\u5173\u5DE5\u4F5C\u6A21\u5F0F" }[n]), Gn() ? alert((s = i != null ? i : n) != null ? s : t) : i ? this.result = i : alert(n != null ? n : t) }, isSupported() { try { BigInt(1) } catch { return !1 } return !!navigator.usb } }); c_(De, ".alert"); Ur.data("ADB", f_); Ur.start();
